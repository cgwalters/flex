# Mensajes en español para GNU flex.
# Copyright (C) 1997 Free Software Foundation, Inc.
# Nicolás García Pedrajas <ma1gapen@uco.es>, 1997.
# ## 23 de septiembre de 1996,
# ## Finaliza la tradución y la dejo para revisión
# ## No me machaquéis mucho, es la primera que hago.
#
# Gracias a Nicolás Fernández García que me ha sugerido algunas ideas.
#
msgid ""
msgstr ""
"Project-Id-Version: GNU flex 2.5.2\n"
"POT-Creation-Date: 2002-03-12 12:07-0500\n"
"PO-Revision-Date: 1997-01-17 12:43+0100\n"
"Last-Translator: Nicolás García Pedrajas <ma1gapen@uco.es>\n"
"Language-Team: Spanish <es@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=ISO-8859-1\n"
"Content-Transfer-Encoding: 8-bit\n"

# El estado (?) sv
#: dfa.c:64
#, c-format
msgid "State #%d is non-accepting -\n"
msgstr "El estado #%d es no-aceptar -\n"

#: dfa.c:131
msgid "dangerous trailing context"
msgstr "contexto posterior peligroso"

#: dfa.c:174
msgid " associated rule line numbers:"
msgstr " números de línea asociados a la regla:"

#: dfa.c:212
msgid " out-transitions: "
msgstr " fin de transiciones: "

#: dfa.c:220
msgid ""
"\n"
" jam-transitions: EOF "
msgstr ""
"\n"
" transiciones de bloqueo: fin de archivo (EOF)"

# Teste no lo he oído en mi vida. ¿te suena mal test a secas?
# o quizá ¿examen de consistencia? em
# Pongo comillas a la función em
# Con teste me estoy haciendo famoso, cada vez que lo escribo
# me lo preguntan. Lo que ocurre es que teste es el término que ha
# aceptado la Real Academia, por eso creo que debíamos usarlo. ng
# Bueno, no vamos a ser más papistas que el Papa, pero que a mí me
# sigue sonando raro em
# pues el verbo es testar, ¿cómo te suena? ng+
#
# Sugiero usar prueba o comprobación. sv
#: dfa.c:357
msgid "consistency check failed in epsclosure()"
msgstr "el teste de consistencia falló en `epsclosure()'"

# ¿Qué tal volcado? em
# ok, a mí tampoco me gustaba descarga ng
#: dfa.c:443
msgid ""
"\n"
"\n"
"DFA Dump:\n"
"\n"
msgstr ""
"\n"
"\n"
"Volcado AFD:\n"
"\n"

#: dfa.c:589
msgid "could not create unique end-of-buffer state"
msgstr "no se pudo crear un estado único de final-de-buffer"

#: dfa.c:610
#, c-format
msgid "state # %d:\n"
msgstr "estado # %d:\n"

# Te he corregido un error de tecleo, y puesto entre comillas
# la llamada a la función em
# ok, lo de las comillas no lo sabía ng
#: dfa.c:994
msgid "consistency check failed in symfollowset"
msgstr "falló el test de consistencia en `symfollowset'"

#: dfa.c:1047
msgid "bad transition character detected in sympartition()"
msgstr "carácter de transición erróneo detectado en sympartition()"

#: gen.c:251
msgid ""
"\n"
"\n"
"Equivalence Classes:\n"
"\n"
msgstr ""
"\n"
"\n"
"Clases de equivalencia:\n"
"\n"

#: gen.c:429 gen.c:913
#, c-format
msgid "state # %d accepts: [%d]\n"
msgstr "el estado # %d acepta: [%d]\n"

#: gen.c:834
#, c-format
msgid "state # %d accepts: "
msgstr "el estado # %d acepta: "

# ¿No sería mejor "MetaEquivalencia" o "Meta-Equivalencia"? sv
# yo prefiero como está, es el mismo caso de metafísica ng+
#: gen.c:936
msgid ""
"\n"
"\n"
"Meta-Equivalence Classes:\n"
msgstr ""
"\n"
"\n"
"Clases de metaequivalencia:\n"

# ¿coincidencia?, es la traducción habitual em
# La traducción de match no me gusta pero no encuentro otra
# Sugerencia: satisface, encaja, es aplicable. sv
# match se traduce por emparejar cuando se usa para emparejar una llave
# abierta con una cerrada, por ejemplo, pero no cuando se trata de ver
# si una regla "matches" o no "matches".
# creo que aplicar no qeuda mal ng+
#: main.c:155
msgid "rule cannot be matched"
msgstr "la regla no se puede aplicar"

# ## re-redacto el mensaje. sv
#: main.c:160
msgid "-s option given but default rule can be matched"
msgstr ""
"se ha especificado la opción -s pero se puede aplicar la regla por defecto"

#: main.c:184
msgid "Can't use -+ with -l option"
msgstr "No se puede usar -+ con la opción -l"

#: main.c:187
msgid "Can't use -f or -F with -l option"
msgstr "No se pueden usar las opciones -f o -F con la opción -l"

#: main.c:190
#, fuzzy
msgid "Can't use -R or -Rb with -l option"
msgstr "No se pueden usar las opciones -f o -F con la opción -l"

#: main.c:203
msgid "Can't specify header option if writing to stdout."
msgstr ""

# ¿juntos o juntas?
# Creo que está bien así em
# ok ng
#: main.c:229
msgid "-Cf/-CF and -Cm don't make sense together"
msgstr "-Cf/-CF y -Cm no tienen sentido juntos"

# no se si poner y ó e
# A mí tambien me hubiese pasado, creo que está bien así em
# entonces lo dejo ng
# Yo creo que en este caso no hace falta porque se leería así:
# "menos ce efe o menos ce efe mayúscula y menos I son incompatibles". sv
#: main.c:232
msgid "-Cf/-CF and -I are incompatible"
msgstr "-Cf/-CF e -I son incompatibles"

#: main.c:236
msgid "-Cf/-CF are incompatible with lex-compatibility mode"
msgstr "-Cf/-CF son incompatibles con el modo de compatibilidad con lex"

#: main.c:240
#, c-format
msgid "-Cf/-CF and %option yylineno are incompatible"
msgstr "-Cf/-CF y la %opción yylineno son incompatibles"

#: main.c:243
msgid "-Cf and -CF are mutually exclusive"
msgstr "-Cf y -CF son mutuamente excluyentes"

#: main.c:247
msgid "Can't use -+ with -CF option"
msgstr "No se puede usar -+ con la opción -CF"

#: main.c:251
#, c-format
msgid "%array incompatible with -+ option"
msgstr "%array incompatible con la opción -+"

#: main.c:256
#, fuzzy
msgid "Options -+ and -R are mutually exclusive."
msgstr "-Cf y -CF son mutuamente excluyentes"

#: main.c:308 main.c:494
#, c-format
msgid "could not create %s"
msgstr "no se pudo crear %s"

# Lo mismo con skeleton, máscara o modelo em
# lo mismo de antes ng
# Lo mismo que antes :) em
# idem ng+
#: main.c:314
#, c-format
msgid "can't open skeleton file %s"
msgstr "no se puede abrir el archivo de esquema %s"

# Skeleton se puede traducir por máscara, o por modelo em
# Sí, lo estuve considerando. Pero el eskeleton file es un fichero que
# le indica a flex la forma como tratar el fichero de entrada, y por eso me
# perece que se puede poner mejor esquema, en el sentido de esquema de
# comportamiento, como en algorítmica ng
# No me has convencido nada. Esquema es una cosa, y esquema de comportamiento
# otra muy distinta. No hay mucha gente que asocie las dos cosas.
# Por otro lado, ya que es una cosa que acepta sólo a los muy avanzados
# usuarios, creo que no hace falta buscar palabras que no significan lo que
# son. Todos los que sepan qué es el eskeleton file sabrán lo que es el archivo
# de máscara, pero por otro lado lo del archivo de esquema puede confundir
# a los profanos en la materia, pensando que se refiere al propio scanner.
# No le veo ninguna ventaja a usar esquema, y sí dos inconvenientes em
# que decida una tercera persona
#
# ## Cambio "leyendo" por "al leer", como en otras traducciones. sv
#: main.c:472
#, c-format
msgid "input error reading skeleton file %s"
msgstr "error de entrada al leer el archivo de esquema %s"

# Otra vez :) em
#: main.c:476
#, c-format
msgid "error closing skeleton file %s"
msgstr "error al cerrar el archivo de esquema %s"

# Lo mismo, archivo de seguridad? em
#: main.c:659
#, fuzzy, c-format
msgid "error creating header file %s"
msgstr "error al escribir el archivo de seguridad %s"

#: main.c:667
#, c-format
msgid "error writing output file %s"
msgstr "error al escribir el archivo de salida %s"

#: main.c:671
#, c-format
msgid "error closing output file %s"
msgstr "error al cerrar el archivo de salida %s"

#: main.c:675
#, c-format
msgid "error deleting output file %s"
msgstr "error al borrar el archivo de salida %s"

# Copia de seguridad? em
# Sugerencia: No hay retroceso. sv
#: main.c:683
msgid "No backing up.\n"
msgstr "Sin retroceso.\n"

#: main.c:686
#, c-format
msgid "%d backing up (non-accepting) states.\n"
msgstr "%d estados de retroceso (no-aceptación).\n"

# Esta frase no me convence demasiado. Si tradujésemos de español
# a inglés lo que hay ahora en español diría algo así como:
# "Compressed tables are always back up"
# (supuesto que back es irregular y su pasado/participio es back y no backed,
# que ahora mismo no me acuerdo). sv
#: main.c:690
msgid "Compressed tables always back up.\n"
msgstr "Las tablas comprimidas siempre implican un retraso.\n"

# Lo mismo, archivo de seguridad? em
#: main.c:693
#, c-format
msgid "error writing backup file %s"
msgstr "error al escribir el archivo de seguridad %s"

#  En todas las traducciones que ha aparecido
#  he sugerido el uso de copia de seguridad em
# ok ng
#: main.c:697
#, c-format
msgid "error closing backup file %s"
msgstr "error al cerrar el archivo de copia de seguridad %s"

#: main.c:703
#, c-format
msgid "%s version %s usage statistics:\n"
msgstr "%s versión %s estadísticas de uso:\n"

#: main.c:706
msgid "  scanner options: -"
msgstr "  opciones del analizador: -"

# NFA significa non-deterministic finite automata, así que lo he traducido
# por AFN
#: main.c:784
#, c-format
msgid "  %d/%d NFA states\n"
msgstr "  %d/%d estados AFN\n"

# DFA significa deterministic finite autómata, lo he traducido por AFD
#: main.c:786
#, c-format
msgid "  %d/%d DFA states (%d words)\n"
msgstr "  %d/%d estados AFD {%d palabras}\n"

#: main.c:788
#, c-format
msgid "  %d rules\n"
msgstr "  %d reglas\n"

# Otra vez ;) em
# modificado como en la anterior ng
#: main.c:792
msgid "  No backing up\n"
msgstr "  Sin retroceso\n"

#: main.c:795
#, c-format
msgid "  %d backing-up (non-accepting) states\n"
msgstr "  %d estados de retroceso (no-aceptación)\n"

# FIXME.
# Informar al autor de que esta frase es casi idéntica a una anterior, para
# que sólo haya que traducirla una vez. sv
#: main.c:799
msgid "  Compressed tables always back-up\n"
msgstr "  Siempre se realiza copia de seguridad de las tablas comprimidas\n"

# Lo mismo "se han usado patrones de comienzo de línea". sv
#: main.c:803
msgid "  Beginning-of-line patterns used\n"
msgstr "  Usados patrones de comienzo-de-línea\n"

#: main.c:805
#, c-format
msgid "  %d/%d start conditions\n"
msgstr "  %d/%d condiciones de activación\n"

# Lo de estados épsilon lo entenderá un usuario avanzado, pero no sé si uno
# normal.
# Yo soy uno normal, y no sé lo que es em
# en teoría de autómatas no deterministas un estado épsilon es un estado
# en el que se puede realizar una transición no trivial sin leer nada,
# lo de doble épsilon no lo he oído nunca. Creo que hay que dejar el término
# técnico. ng
# Tu mandas, no tengo nada que decir a eso em
#: main.c:808
#, c-format
msgid "  %d epsilon states, %d double epsilon states\n"
msgstr "  %d estados épsilon, %d estados doble épsilon\n"

#: main.c:812
msgid "  no character classes\n"
msgstr "  sin clases de caracteres\n"

#: main.c:815
#, c-format
msgid "  %d/%d character classes needed %d/%d words of storage, %d reused\n"
msgstr ""
"  las clases de caracteres %d/%d necesitaron %d/%d palabras de\n"
"almacenamiento, %d reutilizadas\n"

# Frases como esta quedan algo sosas.
# ¿Qué tal "  se han creado %d pares estado/estado-siguiente"?
# Bueno, mejor no lo hagas hasta que no se sepa cómo queda al lado
# de las otras. sv
#: main.c:820
#, c-format
msgid "  %d state/nextstate pairs created\n"
msgstr "  %d pares estado/estado-siguiente creados\n"

# ## Añado sendas eses, ya que son transiciones. sv
#: main.c:822
#, c-format
msgid "  %d/%d unique/duplicate transitions\n"
msgstr "  %d/%d transiciones únicas/duplicadas\n"

# Entradas 'en' la tabla em
# sí, mejor ng
# ¿Que había antes? (¿entradas a la tabla?)
# (entradas *de* la tabla me suena mejor) sv.
#: main.c:828
#, c-format
msgid "  %d table entries\n"
msgstr "  %d entradas en la tabla\n"

# ## pongo `comillas' en el base-def. sv
#: main.c:836
#, c-format
msgid "  %d/%d base-def entries created\n"
msgstr "  %d/%d entradas `base-def' creadas\n"

#: main.c:839
#, c-format
msgid "  %d/%d (peak %d) nxt-chk entries created\n"
msgstr "  %d/%d (pico %d) entradas nxt-chk creadas\n"

#: main.c:842
#, c-format
msgid "  %d/%d (peak %d) template nxt-chk entries created\n"
msgstr " %d/%d (pico %d) entradas de plantilla nxt-chk creadas\n"

# ¿entradas a la tabla o entradas de la tabla? sv
#: main.c:846
#, c-format
msgid "  %d empty table entries\n"
msgstr "  %d entradas en la tabla vacías\n"

#: main.c:848
#, c-format
msgid "  %d protos created\n"
msgstr "  %d prototipos creados\n"

#: main.c:851
#, c-format
msgid "  %d templates created, %d uses\n"
msgstr "  %d plantillas creadas, %d usos\n"

#: main.c:859
#, c-format
msgid "  %d/%d equivalence classes created\n"
msgstr "  %d/%d clases de equivalencia creadas\n"

# "se han creado..." sv
#: main.c:867
#, c-format
msgid "  %d/%d meta-equivalence classes created\n"
msgstr "  %d/%d clases de metaequivalencia creadas\n"

# A veces he visto traducir hash (o hashing) por desmenuzamiento, pero no
# me gusta
# demasiado. De todas formas es un término bastante usado sin traducir.
# A mí hash no me sugiere nada . Piensa en algo mejor, de momento lo dejo
# entre comillas em
# en cierto modo 'colisiones en la localización' sería una idea parecida
# quizás se pueda usar ng
# Me gusta más, pero ya te digo, soy un usuario de andar por casa, y sigo
# sin entender qué es em
# la idea del hash consiste en almacenar un registro (de cualquier tipo) en
# un lugar que se puede determinar mediante una transformación directa de su
# clave, por eso si hay dos claves iguales hay una colisión, porque dos
# registros van al mismo sitio ng+
#: main.c:872
#, c-format
msgid "  %d (%d saved) hash collisions, %d DFAs equal\n"
msgstr ""
"  %d (%d almacenadas) colisiones de localización ('hash'), %d AFDs iguales\n"

#: main.c:874
#, c-format
msgid "  %d sets of reallocations needed\n"
msgstr "  se necesitan %d conjuntos de relocalización\n"

# Lo mismo que en otro sitio: ¿table entries son entradas a la tabla o
# de la tabla? sv
#: main.c:876
#, c-format
msgid "  %d total table entries needed\n"
msgstr "  se necesitan %d entradas totales en la tabla\n"

#: main.c:933
msgid "Internal error. flexopts are malformed.\n"
msgstr ""

# Sugerencia: modificador '%c' desconocido -> opción '%c' desconocida. sv
# ## usage - modo de empleo
# ## pongo try - pruebe, como en otras traducciones. sv
#: main.c:941
#, fuzzy, c-format
msgid ""
"For usage, try\n"
"\t%s --help\n"
msgstr ""
"%s: modificador '%c' desconocido. Para el modo de empleo, pruebe\n"
"\t%s --help\n"

#: main.c:1001
#, c-format
msgid "unknown -C option '%c'"
msgstr "opción -C desconocida '%c'"

#: main.c:1080
#, fuzzy, c-format
msgid "unknown -R option '%c'"
msgstr "opción -C desconocida '%c'"

#: main.c:1113
#, c-format
msgid "%s version %s\n"
msgstr "%s versión %s\n"

# Creo que no existe traducción de parse, en todo lo referente a compiladores
# y autómatas yo siempre lo he visto así.
# Existe alguna solución a 'parse', ¿qué tal
#  al analizar la sintaxis? em
# pero es que el parse es sólo una parte del analizador sintáctico
# aunque desde luego sería mucho más sencillo de entender el mensaje ng
# Habrá que plantearlo en el consejo de ancianos de Spanglish, que a veces
# resuelven mucho em
# ok, ¿cómo se le plantea? ng
# Sugerencia: error fatal. sv
# con comillas es un término medio. Lo de error grave fue una sugerencia
# de Enrique, y croe que queda mejor. ng+
#: main.c:1355
msgid "fatal parse error"
msgstr "error muy grave en el analizador sintáctico"

# Esto no tiene sentido. Uso flex a menudo, y no recuerdo haber visto
# este mensaje nunca. Pero no me parezca que tenga mucho sentido así
# em, ¿a qué se está refiriendo? em
# la verdad es que yo tampoco he usado esta opción, así que he aplicado la
# ley de Murphy, cuando todo lo demás falle, lea el manual. El archivo al
# que se refiere informa sobre todas las reglas que obligan a un retroceso
# del analizador, he rehecho el mensaje para que sea más claro ng
#
# Pues si este "backing" se refiere a un retroceso del analizador, los
# demás también, ¿no? (y no a "copias de seguridad"). sv
#
# ## Perfecto !, pero ten cuidado con los espacios despues del comienzo de línea
# ## , ejemplo
# ##
# ## msgstr " bla bla .. \n"
# ##    "bla bla ..."
# ##
# ## Eso no es válido ( solución, usa emacs po-mode :) ) em
# ## ok, ya estoy instalando linux otra vez ng+
#: main.c:1367
#, c-format
msgid "could not create backing-up info file %s"
msgstr ""
"no se pudo crear el archivo de información de las reglas\n"
"que producen un retroceso del analizador %s"

#: main.c:1389
msgid "-l AT&T lex compatibility option entails a large performance penalty\n"
msgstr ""
"-l la opción de compatibilidad con AT&T lex implica una penalización del\n"
"rendimiento muy alta\n"

#: main.c:1391
msgid " and may be the actual source of other reported performance penalties\n"
msgstr ""
" y puede ser el origen real de otras penalizaciones del rendimiento "
"notificadas\n"

#: main.c:1397
#, c-format
msgid "%%option yylineno entails a large performance penalty\n"
msgstr ""
"la %%opción yylineno implica una penalización del rendimiento muy alta\n"

#: main.c:1404
msgid "-I (interactive) entails a minor performance penalty\n"
msgstr "-I (interactivo) implica una pequeña penalización del rendimiento\n"

#: main.c:1408
msgid "yymore() entails a minor performance penalty\n"
msgstr "yymore() implica un pequeña penalización del rendimiento\n"

#: main.c:1413
msgid "REJECT entails a large performance penalty\n"
msgstr "REJECT implica una penalización del rendimiento muy alta\n"

#: main.c:1417
msgid "Variable trailing context rules entail a large performance penalty\n"
msgstr ""
"La existencia de reglas de contexto posterior variable implica una\n"
"penalización del rendimiento muy alta\n"

#: main.c:1430
msgid "REJECT cannot be used with -f or -F"
msgstr "REJECT no se puede usar con -f o -F"

#: main.c:1433
#, c-format
msgid "%option yylineno cannot be used with -f or -F"
msgstr "la %opción yylineno no se puede usar con -f o -F"

#: main.c:1436
msgid "variable trailing context rules cannot be used with -f or -F"
msgstr ""
"las reglas de contexto posterior variable no se pueden usar con -f o -F"

#: main.c:1567
#, c-format
msgid "%option yyclass only meaningful for C++ scanners"
msgstr "la %option yyclass sólo tiene sentido para los analizadores en C++"

#: main.c:1671
#, c-format
msgid "%s [OPTIONS...] [file...]\n"
msgstr ""

#: main.c:1674
#, c-format
msgid ""
"Table Compression: (default is -Cem)\n"
"  -Ca, --align      trade off larger tables for better memory alignment\n"
"  -Ce, --ecs        construct equivalence classes\n"
"  -Cf               do not compress tables; use -f representation\n"
"  -CF               do not compress tables; use -F representation\n"
"  -Cm, --meta-ecs   construct meta-equivalence classes\n"
"  -Cr, --read       use read() instead of stdio for scanner input\n"
"  -f, --full        generate fast, large scanner. Same as -Cfr\n"
"  -F, --fast        use alternate table representation. Same as -CFr\n"
"\n"
"Debugging:\n"
"  -d, --debug             enable debug mode in scanner\n"
"  -b, --backup            write backing-up information to %s\n"
"  -p, --perf-report       write performance report to stderr\n"
"  -s, --nodefault         suppress default rule to ECHO unmatched text\n"
"  -T, --trace             %s should run in trace mode\n"
"  -w, --nowarn            do not generate warnings\n"
"  -v, --verbose           write summary of scanner statistics to stdout\n"
"\n"
"Files:\n"
"  -o, --outfile=FILE      specify output filename\n"
"  -S, --skel=FILE         specify skeleton file\n"
"  -t, --stdout            write scanner on stdout instead of %s\n"
"      --yyclass=NAME      name of C++ class\n"
"      --header=FILE       create a C header file in addition to the scanner\n"
"\n"
"Scanner behavior:\n"
"  -7, --7bit              generate 7-bit scanner\n"
"  -8, --8bit              generate 8-bit scanner\n"
"  -B, --batch             generate batch scanner (opposite of -I)\n"
"  -i, --case-insensitive  ignore case in patterns\n"
"  -l, --lex-compat        maximal compatibility with original lex\n"
"  -I, --interactive       generate interactive scanner (opposite of -B)\n"
"      --yylineno          track line count in yylineno\n"
"\n"
"Generated code:\n"
"  -+,  --c++               generate C++ scanner class\n"
"  -Dmacro[=defn]           #define macro defn  (default defn is '1')\n"
"  -L,  --noline            suppress #line directives in scanner\n"
"  -P,  --prefix=STRING     use STRING as prefix instead of \"yy\"\n"
"  -R,  --reentrant         generate a reentrant C scanner\n"
"  -Rb, --reentrant-bison   reentrant scanner for bison pure parser.\n"
"       --stdinit           initialize yyin/yyout to stdin/stdout\n"
"       --noFUNCTION        do not generate a particular FUNCTION\n"
"\n"
"Miscellaneous:\n"
"  -c                      do-nothing POSIX option\n"
"  -n                      do-nothing POSIX option\n"
"  -?\n"
"  -h, --help              produce this help message\n"
"  -V, --version           report %s version\n"
msgstr ""

#: misc.c:47
#, c-format
msgid "name \"%s\" ridiculously long"
msgstr "nombre \"%s\" ridículamente grande"

#  Asignación de memoria  em
# ¿está unificado? ng
# Sí, pero creo que sólo por mí. Normalmente esos mensajes
# los dá la biblioteca C antes em
# ok ng+
#: misc.c:101
msgid "memory allocation failed in allocate_array()"
msgstr "falló la asignación de memoria en `allocate_array()'"

#: misc.c:179
#, c-format
msgid "bad character '%s' detected in check_char()"
msgstr "carácter incorrecto '%s' detectado en `check_char()'"

# he añadido el `poder' em
# ok ng
#: misc.c:184
#, c-format
msgid "scanner requires -8 flag to use the character %s"
msgstr "el analizador requiere la opción -8 para poder usar el carácter %s"

#: misc.c:217
msgid "dynamic memory failure in copy_string()"
msgstr "fallo de la memoria dinámica en copy_string()"

# Sugerencia: error fatal. sv
#: misc.c:349
#, c-format
msgid "%s: fatal internal error, %s\n"
msgstr "%s: error interno muy grave, %s\n"

#: misc.c:775
msgid "attempt to increase array size failed"
msgstr "falló el intento de aumentar el tamaño de la matriz"

#: misc.c:842
msgid "bad line in skeleton file"
msgstr "línea incorrecta en el archivo de esquema"

#: misc.c:895
msgid "memory allocation failed in yy_flex_xmalloc()"
msgstr "la reserva de memoria falló en yy_flex_xmalloc()"

#: nfa.c:103
#, c-format
msgid ""
"\n"
"\n"
"********** beginning dump of nfa with start state %d\n"
msgstr ""
"\n"
"\n"
"********** comenzando la descarga del AFN con el estado inicial %d\n"

#: nfa.c:115
#, c-format
msgid "state # %4d\t"
msgstr "estado # %4d\t"

# Sugerencia: volcado. sv
# ok ng+
#: nfa.c:130
msgid "********** end of dump\n"
msgstr "********** fin de volcado\n"

#: nfa.c:176
msgid "empty machine in dupmachine()"
msgstr "máquina vacía en `dupmachine()'"

#: nfa.c:228
#, c-format
msgid "Variable trailing context rule at line %d\n"
msgstr "Regla de contexto posterior variable en la línea %d\n"

#: nfa.c:350
msgid "bad state type in mark_beginning_as_normal()"
msgstr "tipo de estado incorrecto en mark_beginning_as_normal()"

#: nfa.c:603
#, c-format
msgid "input rules are too complicated (>= %d NFA states)"
msgstr "las reglas de entrada son demasiado complicadas (>= %d estados AFN)"

# Sugerencia: se han encontrado... sv
#: nfa.c:682
msgid "found too many transitions in mkxtion()"
msgstr "encontradas demasiadas transiciones en mkxtion()"

#: nfa.c:708
#, c-format
msgid "too many rules (> %d)!"
msgstr "demasiadas reglas (> %d)!"

#: scan.l:139
#, fuzzy, c-format
msgid "unrecognized '%' directive"
msgstr "directiva '%' no reconocida"

#: scan.l:206
msgid "incomplete name definition"
msgstr "definición de nombre incompleta"

#: scan.l:313
#, c-format
msgid "unrecognized %%option: %s"
msgstr "%%opción no reconocida: %s"

#: scan.l:440 scan.l:540
msgid "bad character class"
msgstr "clase de caracteres incorrecta"

#: scan.l:472
#, c-format
msgid "undefined definition {%s}"
msgstr "definición no definida {%s}"

#: scan.l:508
#, c-format
msgid "bad <start condition>: %s"
msgstr "<condición de activación> incorrecta: %s"

# Sugerencia: falta una comilla. sv
#: scan.l:521
msgid "missing quote"
msgstr "falta comilla"

# Corregido el orden de la frase, ponía:
# incorrecta la expresión ... em
# ok, de traducir al final ocurre que acabas hablando al revés,
# como en inglés ng
#: scan.l:561
#, c-format
msgid "bad character class expression: %s"
msgstr "expresión de la clase de caracteres incorrecta: %s"

#: scan.l:577
msgid "bad character inside {}'s"
msgstr "carácter incorrecto dentro de {}'s"

# Sugerencia: "falta una }". sv
#: scan.l:583
msgid "missing }"
msgstr "falta }"

#: scan.l:656
msgid "EOF encountered inside an action"
msgstr "Fin de archivo (EOF) encontrado dentro de una acción"

#: scan.l:676
#, c-format
msgid "bad character: %s"
msgstr "carácter incorrecto: %s"

#: scan.l:705
#, c-format
msgid "can't open %s"
msgstr "no se puede abrir %s"

# Asignación de memoria em
#: sym.c:100
msgid "symbol table memory allocation failed"
msgstr "falló la reserva de memoria para la tabla de símbolos"

# hay que procurar evitar esto, siempre nos suena mejor
# el nombre ha sido definido dos veces, ¿qué te parece? em
# mucho mejor, ya lo había pensado, pero no sabía cual era el estilo usual. ng
#: sym.c:210
msgid "name defined twice"
msgstr "el nombre ha sido definido dos veces"

# Aquí lo mismo 'la condición ... ha sido ..." em
#: sym.c:265
#, c-format
msgid "start condition %s declared twice"
msgstr "la condición de activación %s ha sido declarada dos veces"

#: yylex.c:58
msgid "premature EOF"
msgstr "fin de archivo (EOF) prematuro"

#: yylex.c:207
msgid "End Marker\n"
msgstr "Marcador de fin\n"

# sobre lo de tok, me parece que es abreviatura de token. ng
# en bison he traducido token por terminal, creo que es bueno unificar. ng
#: yylex.c:212
#, c-format
msgid "*Something Weird* - tok: %d val: %d\n"
msgstr "*Algo extraño* - terminal: %d val: %d\n"

# especificar en vez de dar em
# sí, queda mejor ng
#~ msgid "-P flag must be given separately"
#~ msgstr "la opción -P se debe especificar separadamente"

#  especificar, o proporcionar em
# especificar para unificar ng
# Esa es la norma que estamos usando. em
#~ msgid "-o flag must be given separately"
#~ msgstr "la opción -o se debe especificar separadamente"

#  especificar, o proporcionar em
# idem ng
#~ msgid "-S flag must be given separately"
#~ msgstr "la opción -S se debe especificar separadamente"

#  especificar, o proporcionar em
#~ msgid "-C flag must be given separately"
#~ msgstr "la opción -C se debe especificar separadamente"

#  Skeleton otra vez ( recuerdo máscara, o modelos ) em
#~ msgid ""
#~ "%s [-bcdfhilnpstvwBFILTV78+? -C[aefFmr] -ooutput -Pprefix -Sskeleton]\n"
#~ msgstr ""
#~ "%s [-bcdfhilnpstvwBFILTV78+? -C[aefFmr] -osalida -Pprefijo -Sesquema]\n"

#~ msgid "\t[--help --version] [file ...]\n"
#~ msgstr "\t[--help --version] [archivo ...]\n"

# seguridad em
# idem ng
#~ msgid "\t-b  generate backing-up information to %s\n"
#~ msgstr "\t-b  genera la información de los retrocesos efectuados a %s\n"

#  No tiene efecto, en vez de no-hagas-nada em
#  no sé si es lo mismo ng
#  Es como lo estamos traduciendo en otros casos de opciones
# por compatibilidad POSIX pero sin efecto em
# ok ng+
#~ msgid "\t-c  do-nothing POSIX option\n"
#~ msgstr "\t-c  opción POSIX sin efecto\n"

#~ msgid "\t-d  turn on debug mode in generated scanner\n"
#~ msgstr "\t-d  activa el modo de depuración en el analizador generado\n"

#~ msgid "\t-f  generate fast, large scanner\n"
#~ msgstr "\t-f  genera un analizador rápido y grande\n"

#~ msgid "\t-h  produce this help message\n"
#~ msgstr "\t-h  produce este mensaje de ayuda\n"

#~ msgid "\t-i  generate case-insensitive scanner\n"
#~ msgstr ""
#~ "\t-i  genera un analizador que no distingue entre mayúsculas y "
#~ "minúsculas\n"

#~ msgid "\t-l  maximal compatibility with original lex\n"
#~ msgstr "\t-l  compatibilidad máxima con el lex original\n"

# lo mismo que arriba em
#~ msgid "\t-n  do-nothing POSIX option\n"
#~ msgstr "\t-n  opción POSIX sin efecto\n"

# He cambiado el orden salida de error estándar, ponía em
#~ msgid "\t-p  generate performance report to stderr\n"
#~ msgstr ""
#~ "\t-p  genera el informe de rendimiento en la salida de error estándar "
#~ "(stderr)\n"

#~ msgid "\t-s  suppress default rule to ECHO unmatched text\n"
#~ msgstr ""
#~ "\t-s  suprime la regla por defecto de visualizar (ECHO) el texto no "
#~ "emparejado\n"

#~ msgid "\t-t  write generated scanner on stdout instead of %s\n"
#~ msgstr ""
#~ "\t-t  escribe el analizador generado en la salida estándar (stdout) en\n"
#~ "lugar de en %s\n"

#~ msgid "\t-v  write summary of scanner statistics to f\n"
#~ msgstr "\t-v  escribe un resumen de las estadísticas del analizador en f\n"

#~ msgid "\t-w  do not generate warnings\n"
#~ msgstr "\t-w  no genera avisos\n"

# ## cambio opuesta por opuesto.
#~ msgid "\t-B  generate batch scanner (opposite of -I)\n"
#~ msgstr "\t-B  genera un analizador no interactivo (opuesto a -I)\n"

#~ msgid "\t-F  use alternative fast scanner representation\n"
#~ msgstr "\t-F  utiliza la representación de analizador rápido alternativa\n"

#~ msgid "\t-I  generate interactive scanner (opposite of -B)\n"
#~ msgstr "\t-I  genera analizador interactivo (opuesto a -B)\n"

#~ msgid "\t-L  suppress #line directives in scanner\n"
#~ msgstr "\t-L  suprime las directivas #line en el analizador\n"

# modo de seguimiento  em
# ¿está unificado? ng
# Ha salido ya alguna vez, pero no sé si sólo fue en una de mis
# traducciones. Dejémoslo para otro em
#~ msgid "\t-T  %s should run in trace mode\n"
#~ msgstr "\t-T  %s debería ejecutarse en modo traza\n"

#~ msgid "\t-V  report %s version\n"
#~ msgstr "\t-V  informa de la versión de %s\n"

#~ msgid "\t-7  generate 7-bit scanner\n"
#~ msgstr "\t-7  genera un analizador de 7 bits\n"

#~ msgid "\t-8  generate 8-bit scanner\n"
#~ msgstr "\t-8  genera un analizador de 8 bits\n"

# Un analizador C++, sin más, o una clase C++ para el analizador em
# creo que es así, porque genera dos clases C++ ng
# ¿Y?, una pregunta ¿cuál es la clase C++?, tal y como lo traduces
# parece que existiese una sola clase C++ :), sé que el flex te genera
# una clase ( dos ), pero no 'la clase' em
# creo que no me explicado, mi idea es que como genera 2 clases en C++
# el mensaje sería generate C++ scanner classes, luego si está en singular
# creo que se puede referir a que genera un analizador de la clase C++,
# pero creo que a lo mejor el original no se preocupó de esas sutilezas ng+
#
# Pues a mí me parece que lo que genera es una clase analizadora en/de C++
# es decir: "C++ (scanner class)" no "(C++ class) scanner" que sí sería
# un analizador de la clase C++. sv
#~ msgid "\t-+  generate C++ scanner class\n"
#~ msgstr "\t-+  genera una clase analizadora en C++\n"

#~ msgid "\t-?  produce this help message\n"
#~ msgstr "\t-?  produce este mensaje de ayuda\n"

#~ msgid "\t-C  specify degree of table compression (default is -Cem):\n"
#~ msgstr ""
#~ "\t-C  especifica el grado de compresión de la tabla (por defecto -Cem):\n"

#~ msgid "\t\t-Ca  trade off larger tables for better memory alignment\n"
#~ msgstr ""
#~ "\t\t-Ca  renuncia a las tables grandes en favor de una mejor\n"
#~ "\t\t     alineación de la memoria\n"

#~ msgid "\t\t-Ce  construct equivalence classes\n"
#~ msgstr "\t\t-Ce  construye clases de equivalencia\n"

#~ msgid "\t\t-Cf  do not compress scanner tables; use -f representation\n"
#~ msgstr ""
#~ "\t\t-Cf  no comprime las tablas del analizador, utiliza la representación "
#~ "-f\n"

#~ msgid "\t\t-CF  do not compress scanner tables; use -F representation\n"
#~ msgstr ""
#~ "\t\t-CF  no comprime las tablas del analizador, utiliza la representación "
#~ "-F\n"

#~ msgid "\t\t-Cm  construct meta-equivalence classes\n"
#~ msgstr "\t\t-cm  construye clases de metaequivalencia\n"

#~ msgid "\t\t-Cr  use read() instead of stdio for scanner input\n"
#~ msgstr ""
#~ "\t\t-Cr  utiliza read() en lugar de la entrada estándar (stdio) como\n"
#~ "\t\t     entrada al analizador\n"

#~ msgid "\t-o  specify output filename\n"
#~ msgstr "\t-o  especifica el nombre del archivo de salida\n"

#~ msgid "\t-P  specify scanner prefix other than \"yy\"\n"
#~ msgstr "\t-P  especifica un prefijo del analizador distinto de \"yy\"\n"

# De esquema ..., em
#~ msgid "\t-S  specify skeleton file\n"
#~ msgstr "\t-S  especifica el archivo de esquema\n"

#~ msgid "\t--help     produce this help message\n"
#~ msgstr "\t--help     produce este mensaje de ayuda\n"

#~ msgid "\t--version  report %s version\n"
#~ msgstr "\t--version  informa de la versión de %s\n"
