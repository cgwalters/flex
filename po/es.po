# Mensajes en español para GNU flex.
# Copyright (C) 1997 Free Software Foundation, Inc.
# Nicolás García Pedrajas <ma1gapen@uco.es>, 1997.
# ## 23 de septiembre de 1996,
# ## Finaliza la tradución y la dejo para revisión
# ## No me machaquéis mucho, es la primera que hago.
#
# Gracias a Nicolás Fernández García que me ha sugerido algunas ideas.
#
msgid ""
msgstr ""
"Project-Id-Version: GNU flex 2.5.2\n"
"PO-Revision-Date: 1997-01-17 12:43+0100\n"
"Last-Translator: Nicolás García Pedrajas <ma1gapen@uco.es>\n"
"Language-Team: Spanish <es@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=ISO-8859-1\n"
"Content-Transfer-Encoding: 8-bit\n"

# Skeleton se puede traducir por máscara, o por modelo em
# Sí, lo estuve considerando. Pero el eskeleton file es un fichero que
# le indica a flex la forma como tratar el fichero de entrada, y por eso me
# perece que se puede poner mejor esquema, en el sentido de esquema de
# comportamiento, como en algorítmica ng
# No me has convencido nada. Esquema es una cosa, y esquema de comportamiento
# otra muy distinta. No hay mucha gente que asocie las dos cosas.
# Por otro lado, ya que es una cosa que acepta sólo a los muy avanzados
# usuarios, creo que no hace falta buscar palabras que no significan lo que
# son. Todos los que sepan qué es el eskeleton file sabrán lo que es el archivo
# de máscara, pero por otro lado lo del archivo de esquema puede confundir
# a los profanos en la materia, pensando que se refiere al propio scanner.
# No le veo ninguna ventaja a usar esquema, y sí dos inconvenientes em
# que decida una tercera persona
#
# ## Cambio "leyendo" por "al leer", como en otras traducciones. sv
#: main.c:361
msgid "input error reading skeleton file %s"
msgstr "error de entrada al leer el archivo de esquema %s"

#: main.c:898
msgid " and may be the actual source of other reported performance penalties\n"
msgstr ""
" y puede ser el origen real de otras penalizaciones del rendimiento "
"notificadas\n"

# Sugerencia: modificador '%c' desconocido -> opción '%c' desconocida. sv
# ## usage - modo de empleo
# ## pongo try - pruebe, como en otras traducciones. sv
#: main.c:814
msgid ""
"%s: unknown flag '%c'.  For usage, try\n"
"\t%s --help\n"
msgstr ""
"%s: modificador '%c' desconocido. Para el modo de empleo, pruebe\n"
"\t%s --help\n"

#: dfa.c:211
msgid " out-transitions: "
msgstr " fin de transiciones: "

# Esta frase no me convence demasiado. Si tradujésemos de español
# a inglés lo que hay ahora en español diría algo así como:
# "Compressed tables are always back up"
# (supuesto que back es irregular y su pasado/participio es back y no backed,
# que ahora mismo no me acuerdo). sv
#: main.c:394
msgid "Compressed tables always back up.\n"
msgstr "Las tablas comprimidas siempre implican un retraso.\n"

#: main.c:896
msgid "-l AT&T lex compatibility option entails a large performance penalty\n"
msgstr ""
"-l la opción de compatibilidad con AT&T lex implica una penalización del\n"
"rendimiento muy alta\n"

# Sugerencia: falta una comilla. sv
#: scan.l:493
msgid "missing quote"
msgstr "falta comilla"

#: dfa.c:130
msgid "dangerous trailing context"
msgstr "contexto posterior peligroso"

#: main.c:556
msgid "  %d/%d equivalence classes created\n"
msgstr "  %d/%d clases de equivalencia creadas\n"

# ## re-redacto el mensaje. sv
#: main.c:158
msgid "-s option given but default rule can be matched"
msgstr ""
"se ha especificado la opción -s pero se puede aplicar la regla por defecto"

# especificar en vez de dar em
# sí, queda mejor ng
#: main.c:762
msgid "-P flag must be given separately"
msgstr "la opción -P se debe especificar separadamente"

#: gen.c:426 gen.c:902
msgid "state # %d accepts: [%d]\n"
msgstr "el estado # %d acepta: [%d]\n"

#  En todas las traducciones que ha aparecido
#  he sugerido el uso de copia de seguridad em
# ok ng
#: main.c:401
msgid "error closing backup file %s"
msgstr "error al cerrar el archivo de copia de seguridad %s"

#  especificar, o proporcionar em
# especificar para unificar ng
# Esa es la norma que estamos usando. em
#: main.c:753
msgid "-o flag must be given separately"
msgstr "la opción -o se debe especificar separadamente"

#  especificar, o proporcionar em
# idem ng
#: main.c:774
msgid "-S flag must be given separately"
msgstr "la opción -S se debe especificar separadamente"

# Lo mismo con skeleton, máscara o modelo em
# lo mismo de antes ng
# Lo mismo que antes :) em
# idem ng+
#: main.c:302
msgid "can't open skeleton file %s"
msgstr "no se puede abrir el archivo de esquema %s"

#: main.c:545
msgid "  %d protos created\n"
msgstr "  %d prototipos creados\n"

#: dfa.c:1043
msgid "bad transition character detected in sympartition()"
msgstr "carácter de transición erróneo detectado en sympartition()"

#: dfa.c:606
msgid "state # %d:\n"
msgstr "estado # %d:\n"

#  especificar, o proporcionar em
#: main.c:662
msgid "-C flag must be given separately"
msgstr "la opción -C se debe especificar separadamente"

#: main.c:390
msgid "%d backing up (non-accepting) states.\n"
msgstr "%d estados de retroceso (no-aceptación).\n"

#: scan.l:136
msgid "unrecognized '%' directive"
msgstr "directiva '%' no reconocida"

# ¿entradas a la tabla o entradas de la tabla? sv
#: main.c:543
msgid "  %d empty table entries\n"
msgstr "  %d entradas en la tabla vacías\n"

#: main.c:539
msgid "  %d/%d (peak %d) template nxt-chk entries created\n"
msgstr " %d/%d (pico %d) entradas de plantilla nxt-chk creadas\n"

# ## pongo `comillas' en el base-def. sv
#: main.c:533
msgid "  %d/%d base-def entries created\n"
msgstr "  %d/%d entradas `base-def' creadas\n"

#: dfa.c:173
msgid " associated rule line numbers:"
msgstr " números de línea asociados a la regla:"

#: scan.l:286
msgid "unrecognized %%option: %s"
msgstr "%%opción no reconocida: %s"

# FIXME.
# Informar al autor de que esta frase es casi idéntica a una anterior, para
# que sólo haya que traducirla una vez. sv
#: main.c:496
msgid "  Compressed tables always back-up\n"
msgstr "  Siempre se realiza copia de seguridad de las tablas comprimidas\n"

# Lo mismo que en otro sitio: ¿table entries son entradas a la tabla o
# de la tabla? sv
#: main.c:573
msgid "  %d total table entries needed\n"
msgstr "  se necesitan %d entradas totales en la tabla\n"

# ## Añado sendas eses, ya que son transiciones. sv
#: main.c:519
msgid "  %d/%d unique/duplicate transitions\n"
msgstr "  %d/%d transiciones únicas/duplicadas\n"

# Te he corregido un error de tecleo, y puesto entre comillas
# la llamada a la función em
# ok, lo de las comillas no lo sabía ng
#: dfa.c:990
msgid "consistency check failed in symfollowset"
msgstr "falló el test de consistencia en `symfollowset'"

# Corregido el orden de la frase, ponía:
# incorrecta la expresión ... em
# ok, de traducir al final ocurre que acabas hablando al revés,
# como en inglés ng
#: scan.l:533
msgid "bad character class expression: %s"
msgstr "expresión de la clase de caracteres incorrecta: %s"

#: scan.l:444
msgid "undefined definition {%s}"
msgstr "definición no definida {%s}"

# Lo mismo, archivo de seguridad? em
#: main.c:397
msgid "error writing backup file %s"
msgstr "error al escribir el archivo de seguridad %s"

#: scan.l:628
msgid "EOF encountered inside an action"
msgstr "Fin de archivo (EOF) encontrado dentro de una acción"

# Esto no tiene sentido. Uso flex a menudo, y no recuerdo haber visto
# este mensaje nunca. Pero no me parezca que tenga mucho sentido así
# em, ¿a qué se está refiriendo? em
# la verdad es que yo tampoco he usado esta opción, así que he aplicado la
# ley de Murphy, cuando todo lo demás falle, lea el manual. El archivo al
# que se refiere informa sobre todas las reglas que obligan a un retroceso
# del analizador, he rehecho el mensaje para que sea más claro ng
#
# Pues si este "backing" se refiere a un retroceso del analizador, los
# demás también, ¿no? (y no a "copias de seguridad"). sv
#
# ## Perfecto !, pero ten cuidado con los espacios despues del comienzo de línea
# ## , ejemplo
# ##
# ## msgstr " bla bla .. \n"
# ##    "bla bla ..."
# ##
# ## Eso no es válido ( solución, usa emacs po-mode :) ) em
# ## ok, ya estoy instalando linux otra vez ng+
#: main.c:874
msgid "could not create backing-up info file %s"
msgstr ""
"no se pudo crear el archivo de información de las reglas\n"
"que producen un retroceso del analizador %s"

#: main.c:548
msgid "  %d templates created, %d uses\n"
msgstr "  %d plantillas creadas, %d usos\n"

#: main.c:228
msgid "-Cf/-CF are incompatible with lex-compatibility mode"
msgstr "-Cf/-CF son incompatibles con el modo de compatibilidad con lex"

#: scan.l:677
msgid "can't open %s"
msgstr "no se puede abrir %s"

# Otra vez ;) em
# modificado como en la anterior ng
#: main.c:489
msgid "  No backing up\n"
msgstr "  Sin retroceso\n"

# Sugerencia: "falta una }". sv
#: scan.l:555
msgid "missing }"
msgstr "falta }"

# DFA significa deterministic finite autómata, lo he traducido por AFD
#: main.c:483
msgid "  %d/%d DFA states (%d words)\n"
msgstr "  %d/%d estados AFD {%d palabras}\n"

#: scan.l:648
msgid "bad character: %s"
msgstr "carácter incorrecto: %s"

# ¿No sería mejor "MetaEquivalencia" o "Meta-Equivalencia"? sv
# yo prefiero como está, es el mismo caso de metafísica ng+
#: gen.c:925
msgid ""
"\n"
"\n"
"Meta-Equivalence Classes:\n"
msgstr ""
"\n"
"\n"
"Clases de metaequivalencia:\n"

#: main.c:232
msgid "-Cf/-CF and %option yylineno are incompatible"
msgstr "-Cf/-CF y la %opción yylineno son incompatibles"

#: main.c:296
msgid "could not create %s"
msgstr "no se pudo crear %s"

#: dfa.c:585
msgid "could not create unique end-of-buffer state"
msgstr "no se pudo crear un estado único de final-de-buffer"

# Otra vez :) em
#: main.c:365
msgid "error closing skeleton file %s"
msgstr "error al cerrar el archivo de esquema %s"

#: main.c:911
msgid "-I (interactive) entails a minor performance penalty\n"
msgstr "-I (interactivo) implica una pequeña penalización del rendimiento\n"

#: main.c:536
msgid "  %d/%d (peak %d) nxt-chk entries created\n"
msgstr "  %d/%d (pico %d) entradas nxt-chk creadas\n"

#: main.c:235
msgid "-Cf and -CF are mutually exclusive"
msgstr "-Cf y -CF son mutuamente excluyentes"

#: main.c:407
msgid "%s version %s usage statistics:\n"
msgstr "%s versión %s estadísticas de uso:\n"

# ¿juntos o juntas?
# Creo que está bien así em
# ok ng
#: main.c:221
msgid "-Cf/-CF and -Cm don't make sense together"
msgstr "-Cf/-CF y -Cm no tienen sentido juntos"

#: main.c:512
msgid "  %d/%d character classes needed %d/%d words of storage, %d reused\n"
msgstr ""
"  las clases de caracteres %d/%d necesitaron %d/%d palabras de\n"
"almacenamiento, %d reutilizadas\n"

#: main.c:380
msgid "error deleting output file %s"
msgstr "error al borrar el archivo de salida %s"

# Teste no lo he oído en mi vida. ¿te suena mal test a secas?
# o quizá ¿examen de consistencia? em
# Pongo comillas a la función em
# Con teste me estoy haciendo famoso, cada vez que lo escribo
# me lo preguntan. Lo que ocurre es que teste es el término que ha
# aceptado la Real Academia, por eso creo que debíamos usarlo. ng
# Bueno, no vamos a ser más papistas que el Papa, pero que a mí me
# sigue sonando raro em
# pues el verbo es testar, ¿cómo te suena? ng+
#
# Sugiero usar prueba o comprobación. sv
#: dfa.c:356
msgid "consistency check failed in epsclosure()"
msgstr "el teste de consistencia falló en `epsclosure()'"

# NFA significa non-deterministic finite automata, así que lo he traducido
# por AFN
#: main.c:481
msgid "  %d/%d NFA states\n"
msgstr "  %d/%d estados AFN\n"

#: main.c:509
msgid "  no character classes\n"
msgstr "  sin clases de caracteres\n"

#: main.c:904
msgid "%%option yylineno entails a large performance penalty\n"
msgstr ""
"la %%opción yylineno implica una penalización del rendimiento muy alta\n"

#: main.c:182
msgid "Can't use -+ with -l option"
msgstr "No se puede usar -+ con la opción -l"

# ¿Qué tal volcado? em
# ok, a mí tampoco me gustaba descarga ng
#: dfa.c:439
msgid ""
"\n"
"\n"
"DFA Dump:\n"
"\n"
msgstr ""
"\n"
"\n"
"Volcado AFD:\n"
"\n"

#: main.c:410
msgid "  scanner options: -"
msgstr "  opciones del analizador: -"

#: gen.c:823
msgid "state # %d accepts: "
msgstr "el estado # %d acepta: "

# no se si poner y ó e
# A mí tambien me hubiese pasado, creo que está bien así em
# entonces lo dejo ng
# Yo creo que en este caso no hace falta porque se leería así:
# "menos ce efe o menos ce efe mayúscula y menos I son incompatibles". sv
#: main.c:224
msgid "-Cf/-CF and -I are incompatible"
msgstr "-Cf/-CF e -I son incompatibles"

#: scan.l:480
msgid "bad <start condition>: %s"
msgstr "<condición de activación> incorrecta: %s"

#: main.c:492
msgid "  %d backing-up (non-accepting) states\n"
msgstr "  %d estados de retroceso (no-aceptación)\n"

# Lo de estados épsilon lo entenderá un usuario avanzado, pero no sé si uno
# normal.
# Yo soy uno normal, y no sé lo que es em
# en teoría de autómatas no deterministas un estado épsilon es un estado
# en el que se puede realizar una transición no trivial sin leer nada,
# lo de doble épsilon no lo he oído nunca. Creo que hay que dejar el término
# técnico. ng
# Tu mandas, no tengo nada que decir a eso em
#: main.c:505
msgid "  %d epsilon states, %d double epsilon states\n"
msgstr "  %d estados épsilon, %d estados doble épsilon\n"

#: main.c:239
msgid "Can't use -+ with -CF option"
msgstr "No se puede usar -+ con la opción -CF"

# ¿coincidencia?, es la traducción habitual em
# La traducción de match no me gusta pero no encuentro otra
# Sugerencia: satisface, encaja, es aplicable. sv
# match se traduce por emparejar cuando se usa para emparejar una llave
# abierta con una cerrada, por ejemplo, pero no cuando se trata de ver
# si una regla "matches" o no "matches".
# creo que aplicar no qeuda mal ng+
#: main.c:153
msgid "rule cannot be matched"
msgstr "la regla no se puede aplicar"

#: main.c:796
msgid "%s version %s\n"
msgstr "%s versión %s\n"

# Entradas 'en' la tabla em
# sí, mejor ng
# ¿Que había antes? (¿entradas a la tabla?)
# (entradas *de* la tabla me suena mejor) sv.
#: main.c:525
msgid "  %d table entries\n"
msgstr "  %d entradas en la tabla\n"

#: main.c:702
msgid "unknown -C option '%c'"
msgstr "opción -C desconocida '%c'"

#: scan.l:412 scan.l:512
msgid "bad character class"
msgstr "clase de caracteres incorrecta"

#: main.c:185
msgid "Can't use -f or -F with -l option"
msgstr "No se pueden usar las opciones -f o -F con la opción -l"

#: main.c:571
msgid "  %d sets of reallocations needed\n"
msgstr "  se necesitan %d conjuntos de relocalización\n"

# Copia de seguridad? em
# Sugerencia: No hay retroceso. sv
#: main.c:387
msgid "No backing up.\n"
msgstr "Sin retroceso.\n"

#: main.c:243
msgid "%array incompatible with -+ option"
msgstr "%array incompatible con la opción -+"

#: main.c:485
msgid "  %d rules\n"
msgstr "  %d reglas\n"

# Frases como esta quedan algo sosas.
# ¿Qué tal "  se han creado %d pares estado/estado-siguiente"?
# Bueno, mejor no lo hagas hasta que no se sepa cómo queda al lado
# de las otras. sv
#: main.c:517
msgid "  %d state/nextstate pairs created\n"
msgstr "  %d pares estado/estado-siguiente creados\n"

#: scan.l:549
msgid "bad character inside {}'s"
msgstr "carácter incorrecto dentro de {}'s"

# El estado (?) sv
#: dfa.c:63
msgid "State #%d is non-accepting -\n"
msgstr "El estado #%d es no-aceptar -\n"

#: dfa.c:219
msgid ""
"\n"
" jam-transitions: EOF "
msgstr ""
"\n"
" transiciones de bloqueo: fin de archivo (EOF)"

# Lo mismo "se han usado patrones de comienzo de línea". sv
#: main.c:500
msgid "  Beginning-of-line patterns used\n"
msgstr "  Usados patrones de comienzo-de-línea\n"

# "se han creado..." sv
#: main.c:564
msgid "  %d/%d meta-equivalence classes created\n"
msgstr "  %d/%d clases de metaequivalencia creadas\n"

#: main.c:372
msgid "error writing output file %s"
msgstr "error al escribir el archivo de salida %s"

#: gen.c:248
msgid ""
"\n"
"\n"
"Equivalence Classes:\n"
"\n"
msgstr ""
"\n"
"\n"
"Clases de equivalencia:\n"
"\n"

#: main.c:376
msgid "error closing output file %s"
msgstr "error al cerrar el archivo de salida %s"

# Creo que no existe traducción de parse, en todo lo referente a compiladores
# y autómatas yo siempre lo he visto así.
# Existe alguna solución a 'parse', ¿qué tal
#  al analizar la sintaxis? em
# pero es que el parse es sólo una parte del analizador sintáctico
# aunque desde luego sería mucho más sencillo de entender el mensaje ng
# Habrá que plantearlo en el consejo de ancianos de Spanglish, que a veces
# resuelven mucho em
# ok, ¿cómo se le plantea? ng
# Sugerencia: error fatal. sv
# con comillas es un término medio. Lo de error grave fue una sugerencia
# de Enrique, y croe que queda mejor. ng+
#: main.c:862
msgid "fatal parse error"
msgstr "error muy grave en el analizador sintáctico"

#: main.c:502
msgid "  %d/%d start conditions\n"
msgstr "  %d/%d condiciones de activación\n"

# A veces he visto traducir hash (o hashing) por desmenuzamiento, pero no
# me gusta
# demasiado. De todas formas es un término bastante usado sin traducir.
# A mí hash no me sugiere nada . Piensa en algo mejor, de momento lo dejo
# entre comillas em
# en cierto modo 'colisiones en la localización' sería una idea parecida
# quizás se pueda usar ng
# Me gusta más, pero ya te digo, soy un usuario de andar por casa, y sigo
# sin entender qué es em
# la idea del hash consiste en almacenar un registro (de cualquier tipo) en
# un lugar que se puede determinar mediante una transformación directa de su
# clave, por eso si hay dos claves iguales hay una colisión, porque dos
# registros van al mismo sitio ng+
#: main.c:569
msgid "  %d (%d saved) hash collisions, %d DFAs equal\n"
msgstr ""
"  %d (%d almacenadas) colisiones de localización ('hash'), %d AFDs iguales\n"

#: scan.l:203
msgid "incomplete name definition"
msgstr "definición de nombre incompleta"

#: main.c:915
msgid "yymore() entails a minor performance penalty\n"
msgstr "yymore() implica un pequeña penalización del rendimiento\n"

#: main.c:920
msgid "REJECT entails a large performance penalty\n"
msgstr "REJECT implica una penalización del rendimiento muy alta\n"

#: main.c:924
msgid "Variable trailing context rules entail a large performance penalty\n"
msgstr ""
"La existencia de reglas de contexto posterior variable implica una\n"
"penalización del rendimiento muy alta\n"

#: main.c:937
msgid "REJECT cannot be used with -f or -F"
msgstr "REJECT no se puede usar con -f o -F"

#: main.c:940
msgid "%option yylineno cannot be used with -f or -F"
msgstr "la %opción yylineno no se puede usar con -f o -F"

#: main.c:943
msgid "variable trailing context rules cannot be used with -f or -F"
msgstr ""
"las reglas de contexto posterior variable no se pueden usar con -f o -F"

#: main.c:1038
msgid "%option yyclass only meaningful for C++ scanners"
msgstr "la %option yyclass sólo tiene sentido para los analizadores en C++"

#  Skeleton otra vez ( recuerdo máscara, o modelos ) em
#: main.c:1117
msgid "%s [-bcdfhilnpstvwBFILTV78+? -C[aefFmr] -ooutput -Pprefix -Sskeleton]\n"
msgstr ""
"%s [-bcdfhilnpstvwBFILTV78+? -C[aefFmr] -osalida -Pprefijo -Sesquema]\n"

#: main.c:1119
msgid "\t[--help --version] [file ...]\n"
msgstr "\t[--help --version] [archivo ...]\n"

# seguridad em
# idem ng
#: main.c:1121
msgid "\t-b  generate backing-up information to %s\n"
msgstr "\t-b  genera la información de los retrocesos efectuados a %s\n"

#  No tiene efecto, en vez de no-hagas-nada em
#  no sé si es lo mismo ng
#  Es como lo estamos traduciendo en otros casos de opciones
# por compatibilidad POSIX pero sin efecto em
# ok ng+
#: main.c:1123
msgid "\t-c  do-nothing POSIX option\n"
msgstr "\t-c  opción POSIX sin efecto\n"

#: main.c:1124
msgid "\t-d  turn on debug mode in generated scanner\n"
msgstr "\t-d  activa el modo de depuración en el analizador generado\n"

#: main.c:1125
msgid "\t-f  generate fast, large scanner\n"
msgstr "\t-f  genera un analizador rápido y grande\n"

#: main.c:1126
msgid "\t-h  produce this help message\n"
msgstr "\t-h  produce este mensaje de ayuda\n"

#: main.c:1127
msgid "\t-i  generate case-insensitive scanner\n"
msgstr ""
"\t-i  genera un analizador que no distingue entre mayúsculas y minúsculas\n"

#: main.c:1128
msgid "\t-l  maximal compatibility with original lex\n"
msgstr "\t-l  compatibilidad máxima con el lex original\n"

# lo mismo que arriba em
#: main.c:1129
msgid "\t-n  do-nothing POSIX option\n"
msgstr "\t-n  opción POSIX sin efecto\n"

# He cambiado el orden salida de error estándar, ponía em
#: main.c:1130
msgid "\t-p  generate performance report to stderr\n"
msgstr ""
"\t-p  genera el informe de rendimiento en la salida de error estándar "
"(stderr)\n"

#: main.c:1132
msgid "\t-s  suppress default rule to ECHO unmatched text\n"
msgstr ""
"\t-s  suprime la regla por defecto de visualizar (ECHO) el texto no "
"emparejado\n"

#: main.c:1142
msgid "\t-t  write generated scanner on stdout instead of %s\n"
msgstr ""
"\t-t  escribe el analizador generado en la salida estándar (stdout) en\n"
"lugar de en %s\n"

#: main.c:1146
msgid "\t-v  write summary of scanner statistics to f\n"
msgstr "\t-v  escribe un resumen de las estadísticas del analizador en f\n"

#: main.c:1147
msgid "\t-w  do not generate warnings\n"
msgstr "\t-w  no genera avisos\n"

# ## cambio opuesta por opuesto.
#: main.c:1148
msgid "\t-B  generate batch scanner (opposite of -I)\n"
msgstr "\t-B  genera un analizador no interactivo (opuesto a -I)\n"

#: main.c:1150
msgid "\t-F  use alternative fast scanner representation\n"
msgstr "\t-F  utiliza la representación de analizador rápido alternativa\n"

#: main.c:1152
msgid "\t-I  generate interactive scanner (opposite of -B)\n"
msgstr "\t-I  genera analizador interactivo (opuesto a -B)\n"

#: main.c:1153
msgid "\t-L  suppress #line directives in scanner\n"
msgstr "\t-L  suprime las directivas #line en el analizador\n"

# modo de seguimiento  em
# ¿está unificado? ng
# Ha salido ya alguna vez, pero no sé si sólo fue en una de mis
# traducciones. Dejémoslo para otro em
#: main.c:1154
msgid "\t-T  %s should run in trace mode\n"
msgstr "\t-T  %s debería ejecutarse en modo traza\n"

#: main.c:1155
msgid "\t-V  report %s version\n"
msgstr "\t-V  informa de la versión de %s\n"

#: main.c:1156
msgid "\t-7  generate 7-bit scanner\n"
msgstr "\t-7  genera un analizador de 7 bits\n"

#: main.c:1157
msgid "\t-8  generate 8-bit scanner\n"
msgstr "\t-8  genera un analizador de 8 bits\n"

# Un analizador C++, sin más, o una clase C++ para el analizador em
# creo que es así, porque genera dos clases C++ ng
# ¿Y?, una pregunta ¿cuál es la clase C++?, tal y como lo traduces
# parece que existiese una sola clase C++ :), sé que el flex te genera
# una clase ( dos ), pero no 'la clase' em
# creo que no me explicado, mi idea es que como genera 2 clases en C++
# el mensaje sería generate C++ scanner classes, luego si está en singular
# creo que se puede referir a que genera un analizador de la clase C++,
# pero creo que a lo mejor el original no se preocupó de esas sutilezas ng+
#
# Pues a mí me parece que lo que genera es una clase analizadora en/de C++
# es decir: "C++ (scanner class)" no "(C++ class) scanner" que sí sería
# un analizador de la clase C++. sv
#: main.c:1158
msgid "\t-+  generate C++ scanner class\n"
msgstr "\t-+  genera una clase analizadora en C++\n"

#: main.c:1159
msgid "\t-?  produce this help message\n"
msgstr "\t-?  produce este mensaje de ayuda\n"

#: main.c:1161
msgid "\t-C  specify degree of table compression (default is -Cem):\n"
msgstr ""
"\t-C  especifica el grado de compresión de la tabla (por defecto -Cem):\n"

#: main.c:1163
msgid "\t\t-Ca  trade off larger tables for better memory alignment\n"
msgstr ""
"\t\t-Ca  renuncia a las tables grandes en favor de una mejor\n"
"\t\t     alineación de la memoria\n"

#: main.c:1164
msgid "\t\t-Ce  construct equivalence classes\n"
msgstr "\t\t-Ce  construye clases de equivalencia\n"

#: main.c:1166
msgid "\t\t-Cf  do not compress scanner tables; use -f representation\n"
msgstr ""
"\t\t-Cf  no comprime las tablas del analizador, utiliza la representación "
"-f\n"

#: main.c:1168
msgid "\t\t-CF  do not compress scanner tables; use -F representation\n"
msgstr ""
"\t\t-CF  no comprime las tablas del analizador, utiliza la representación "
"-F\n"

#: main.c:1169
msgid "\t\t-Cm  construct meta-equivalence classes\n"
msgstr "\t\t-cm  construye clases de metaequivalencia\n"

#: main.c:1171
msgid "\t\t-Cr  use read() instead of stdio for scanner input\n"
msgstr ""
"\t\t-Cr  utiliza read() en lugar de la entrada estándar (stdio) como\n"
"\t\t     entrada al analizador\n"

#: main.c:1172
msgid "\t-o  specify output filename\n"
msgstr "\t-o  especifica el nombre del archivo de salida\n"

#: main.c:1173
msgid "\t-P  specify scanner prefix other than \"yy\"\n"
msgstr "\t-P  especifica un prefijo del analizador distinto de \"yy\"\n"

# De esquema ..., em
#: main.c:1174
msgid "\t-S  specify skeleton file\n"
msgstr "\t-S  especifica el archivo de esquema\n"

#: main.c:1175
msgid "\t--help     produce this help message\n"
msgstr "\t--help     produce este mensaje de ayuda\n"

#: main.c:1176
msgid "\t--version  report %s version\n"
msgstr "\t--version  informa de la versión de %s\n"

#: misc.c:42
msgid "name \"%s\" ridiculously long"
msgstr "nombre \"%s\" ridículamente grande"

#  Asignación de memoria  em
# ¿está unificado? ng
# Sí, pero creo que sólo por mí. Normalmente esos mensajes
# los dá la biblioteca C antes em
# ok ng+
#: misc.c:91
msgid "memory allocation failed in allocate_array()"
msgstr "falló la asignación de memoria en `allocate_array()'"

#: misc.c:169
msgid "bad character '%s' detected in check_char()"
msgstr "carácter incorrecto '%s' detectado en `check_char()'"

# he añadido el `poder' em
# ok ng
#: misc.c:174
msgid "scanner requires -8 flag to use the character %s"
msgstr "el analizador requiere la opción -8 para poder usar el carácter %s"

#: misc.c:207
msgid "dynamic memory failure in copy_string()"
msgstr "fallo de la memoria dinámica en copy_string()"

# Sugerencia: error fatal. sv
#: misc.c:339
msgid "%s: fatal internal error, %s\n"
msgstr "%s: error interno muy grave, %s\n"

#: misc.c:765
msgid "attempt to increase array size failed"
msgstr "falló el intento de aumentar el tamaño de la matriz"

#: misc.c:811
msgid "bad line in skeleton file"
msgstr "línea incorrecta en el archivo de esquema"

#: misc.c:864
msgid "memory allocation failed in yy_flex_xmalloc()"
msgstr "la reserva de memoria falló en yy_flex_xmalloc()"

#: nfa.c:100
msgid ""
"\n"
"\n"
"********** beginning dump of nfa with start state %d\n"
msgstr ""
"\n"
"\n"
"********** comenzando la descarga del AFN con el estado inicial %d\n"

#: nfa.c:112
msgid "state # %4d\t"
msgstr "estado # %4d\t"

# Sugerencia: volcado. sv
# ok ng+
#: nfa.c:127
msgid "********** end of dump\n"
msgstr "********** fin de volcado\n"

#: nfa.c:173
msgid "empty machine in dupmachine()"
msgstr "máquina vacía en `dupmachine()'"

#: nfa.c:225
msgid "Variable trailing context rule at line %d\n"
msgstr "Regla de contexto posterior variable en la línea %d\n"

#: nfa.c:347
msgid "bad state type in mark_beginning_as_normal()"
msgstr "tipo de estado incorrecto en mark_beginning_as_normal()"

#: nfa.c:600
msgid "input rules are too complicated (>= %d NFA states)"
msgstr "las reglas de entrada son demasiado complicadas (>= %d estados AFN)"

# Sugerencia: se han encontrado... sv
#: nfa.c:679
msgid "found too many transitions in mkxtion()"
msgstr "encontradas demasiadas transiciones en mkxtion()"

#: nfa.c:705
msgid "too many rules (> %d)!"
msgstr "demasiadas reglas (> %d)!"

# Asignación de memoria em
#: sym.c:78
msgid "symbol table memory allocation failed"
msgstr "falló la reserva de memoria para la tabla de símbolos"

# hay que procurar evitar esto, siempre nos suena mejor
# el nombre ha sido definido dos veces, ¿qué te parece? em
# mucho mejor, ya lo había pensado, pero no sabía cual era el estilo usual. ng
#: sym.c:188
msgid "name defined twice"
msgstr "el nombre ha sido definido dos veces"

# Aquí lo mismo 'la condición ... ha sido ..." em
#: sym.c:243
msgid "start condition %s declared twice"
msgstr "la condición de activación %s ha sido declarada dos veces"

#: yylex.c:55
msgid "premature EOF"
msgstr "fin de archivo (EOF) prematuro"

#: yylex.c:204
msgid "End Marker\n"
msgstr "Marcador de fin\n"

# sobre lo de tok, me parece que es abreviatura de token. ng
# en bison he traducido token por terminal, creo que es bueno unificar. ng
#: yylex.c:209
msgid "*Something Weird* - tok: %d val: %d\n"
msgstr "*Algo extraño* - terminal: %d val: %d\n"
