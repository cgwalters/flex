\input texinfo.tex @c -*-texinfo-*-
@c %**start of header
@setfilename flex.info
@settitle The Flex Manual
@c %**end of header

@c  This file is part of flex.

@c  Copyright (c) 1990, 1997 The Regents of the University of California.
@c  All rights reserved.

@c  This code is derived from software contributed to Berkeley by
@c  Vern Paxson.

@c  The United States Government has rights in this work pursuant
@c  to contract no. DE-AC03-76SF00098 between the United States
@c  Department of Energy and the University of California.

@c   Redistribution and use in source and binary forms, with or without
@c   modification, are permitted provided that the following conditions
@c   are met:

@c   1. Redistributions of source code must retain the above copyright
@c      notice, this list of conditions and the following disclaimer.
@c   2. Redistributions in binary form must reproduce the above copyright
@c      notice, this list of conditions and the following disclaimer in the
@c      documentation and/or other materials provided with the distribution.

@c   Neither the name of the University nor the names of its contributors
@c   may be used to endorse or promote products derived from this software
@c   without specific prior written permission.

@c   THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
@c   IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
@c   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
@c   PURPOSE.
@node Top, introduction, (dir), (dir)
@top flex

This manual describes
@code{flex},
a tool for generating programs that perform pattern-matching on text.  The
manual includes both tutorial and reference sections.

@menu
* introduction::                
* simple examples::             
* format::                      
* Patterns::                    
* matching::                    
* actions::                     
* generated scanner::           
* start conditions::            
* multiple::                    
* eof::                         
* misc macros::                 
* user values::                 
* yacc::                        
* invoking flex::               
* scanner options::             
* performance::                 
* cxx::                         
* reentrant::                   
* lex and posix::               
* diagnostics::                 
* limitations::                 
* bibliography::                
* copyright::                   
* reporting bugs::              
@end menu

@node introduction, simple examples, Top, Top
@chapter Introduction

@code{flex}
is a tool for generating
@dfn{scanners}.
A scanner is a program which recognizes lexical patterns in text.
The
@code{flex}
program
reads
the given input files, or its standard input if no file names are given,
for a description of a scanner to generate.  The description is in
the form of pairs
of regular expressions and C code, called
@dfn{rules}. @code{flex}
generates as output a C source file,
@file{lex.yy.c} by default,
which defines a routine
@b{yylex()}.
This file is compiled and linked with the
flex runtime library
library to produce an executable.  When the executable is run,
it analyzes its input for occurrences
of the regular expressions.  Whenever it finds one, it executes
the corresponding C code.

@menu
* simple examples::             
* format::                      
* Patterns::                    
* matching::                    
* actions::                     
* generated scanner::           
* start conditions::            
* multiple::                    
* invoking flex::               
* performance::                 
* cxx::                         
* reentrant::                   
* diagnostics::                 
* limitations::                 
* bibliography::                
@end menu

@node simple examples, format, introduction, Top
@chapter SOME SIMPLE EXAMPLES

First some simple examples to get the flavor of how one uses
@code{flex}.
The following
@code{flex}
input specifies a scanner which whenever it encounters the string
@samp{username} will replace it with the user's login name:

@verbatim
    %%
    username    printf( "%s", getlogin() );
@end verbatim

By default, any text not matched by a
@code{flex}
scanner
is copied to the output, so the net effect of this scanner is
to copy its input file to its output with each occurrence
of @samp{username} expanded.
In this input, there is just one rule.  @samp{username} is the
@dfn{pattern}
and the @samp{printf} is the
@dfn{action}.
The @samp{%%} symbol marks the beginning of the rules.

Here's another simple example:

@example
@verbatim
            int num_lines = 0, num_chars = 0;

    %%
    \n      ++num_lines; ++num_chars;
    .       ++num_chars;

    %%
    main()
            {
            yylex();
            printf( "# of lines = %d, # of chars = %d\n",
                    num_lines, num_chars );
            }
@end verbatim
@end example

This scanner counts the number of characters and the number
of lines in its input (it produces no output other than the
final report on the counts).  The first line
declares two globals, @code{num_lines} and @code{num_chars}, which are accessible
both inside
@code{yylex()}
and in the
@code{main()}
routine declared after the second @samp{%%}.  There are two rules, one
which matches a newline (@samp{\n}) and increments both the line count and
the character count, and one which matches any character other than
a newline (indicated by the @samp{.} regular expression).

A somewhat more complicated example:

@example
@verbatim
    /* scanner for a toy Pascal-like language */

    %{
    /* need this for the call to atof() below */
    #include math.h>
    %}

    DIGIT    [0-9]
    ID       [a-z][a-z0-9]*

    %%

    {DIGIT}+    {
                printf( "An integer: %s (%d)\n", yytext,
                        atoi( yytext ) );
                }

    {DIGIT}+"."{DIGIT}*        {
                printf( "A float: %s (%g)\n", yytext,
                        atof( yytext ) );
                }

    if|then|begin|end|procedure|function        {
                printf( "A keyword: %s\n", yytext );
                }

    {ID}        printf( "An identifier: %s\n", yytext );

    "+"|"-"|"*"|"/"   printf( "An operator: %s\n", yytext );

    "{"[\^{}}\n]*"}"     /* eat up one-line comments */

    [ \t\n]+          /* eat up whitespace */

    .           printf( "Unrecognized character: %s\n", yytext );

    %%

    main( argc, argv )
    int argc;
    char **argv;
        {
        ++argv, --argc;  /* skip over program name */
        if ( argc > 0 )
                yyin = fopen( argv[0], "r" );
        else
                yyin = stdin;
        
        yylex();
        }
@end verbatim
@end example

This is the beginnings of a simple scanner for a language like
Pascal.  It identifies different types of
@dfn{tokens}
and reports on what it has seen.

The details of this example will be explained in the following
sections.

@node format, Patterns, simple examples, Top
@chapter FORMAT OF THE INPUT FILE

The
@code{flex}
input file consists of three sections, separated by a line with just
@samp{%%}
in it:

@example
@verbatim
    definitions
    %%
    rules
    %%
    user code
@end verbatim
@end example

The
@i{definitions}
section contains declarations of simple
@i{name}
definitions to simplify the scanner specification, and declarations of
@i{start conditions},
which are explained in a later section.

Name definitions have the form:

@example
@verbatim
    name definition
@end verbatim
@end example

The @samp{name} is a word beginning with a letter or an underscore (@samp{_})
followed by zero or more letters, digits, @samp{_}, or @samp{-} (dash).
The definition is taken to begin at the first non-whitespace character
following the name and continuing to the end of the line.
The definition can subsequently be referred to using @samp{@{name@}}, which
will expand to @samp{(definition)}.  For example,

@example
@verbatim
    DIGIT    [0-9]
    ID       [a-z][a-z0-9]*
@end verbatim
@end example

Defines @samp{DIGIT} to be a regular expression which matches a
single digit, and
@samp{ID} to be a regular expression which matches a letter
followed by zero-or-more letters-or-digits.
A subsequent reference to

@example
@verbatim
    {DIGIT}+"."{DIGIT}*
@end verbatim
@end example

is identical to

@example
@verbatim
    ([0-9])+"."([0-9])*
@end verbatim
@end example

and matches one-or-more digits followed by a '.' followed
by zero-or-more digits.

The
@i{rules}
section of the
@code{flex}
input contains a series of rules of the form:

@example
@verbatim
    pattern   action
@end verbatim
@end example

where the pattern must be unindented and the action must begin
on the same line.

@xref{Patterns}, for a further description of patterns and actions.

Finally, the user code section is simply copied to
@file{lex.yy.c}
verbatim.
It is used for companion routines which call or are called
by the scanner.  The presence of this section is optional;
if it is missing, the second
@samp{%%}
in the input file may be skipped, too.

In the definitions and rules sections, any
@emph{indented}
text or text enclosed in
@samp{%@{}
and
@samp{%@}}
is copied verbatim to the output (with the %@{ and %@} symbols removed).
The %@{ and %@} symbols must appear unindented on lines by themselves.

In the rules section,
any indented or %@{ %@} enclosed text appearing before the
first rule may be used to declare variables
which are local to the scanning routine and (after the declarations)
code which is to be executed whenever the scanning routine is entered.
Other indented or %@{ %@} text in the rule section is still copied to the output,
but its meaning is not well-defined and it may well cause compile-time
errors (this feature is present for
@i{POSIX}
compliance. @xref{lex and posix}, for other such features).

In the definitions section (but not in the rules section),
an unindented comment (i.e., a line
beginning with @samp{/*}) is also copied verbatim to the output up
to the next @samp{*/}.

@node Patterns, matching, format, Top
@chapter PATTERNS

The patterns in the input are written using an extended set of regular
expressions.  These are:

@table @samp
@item x
match the character 'x'

@item .
any character (byte) except newline

@item [xyz]
a @dfn{character class}; in this case, the pattern
matches either an 'x', a 'y', or a 'z'

@item [abj-oZ]
a "character class" with a range in it; matches
an 'a', a 'b', any letter from 'j' through 'o',
or a 'Z'

@item [^A-Z]
a "negated character class", i.e., any character
but those in the class.  In this case, any
character EXCEPT an uppercase letter.

@item [^A-Z\n]
any character EXCEPT an uppercase letter or
a newline

@item r*
zero or more r's, where r is any regular expression

@item r+
one or more r's

@item r?
zero or one r's (that is, ``an optional r'')

@item r@{2,5@}
anywhere from two to five r's

@item r@{2,@}
two or more r's

@item r@{4@}
exactly 4 r's

@item @{name@}
the expansion of the @samp{name} definition
(@pxref{format}).

@item "[xyz]\"foo"
the literal string: @samp{[xyz]"foo}

@item \X
if X is @samp{a}, @samp{b}, @samp{f}, @samp{n}, @samp{r}, @samp{t}, or @samp{v},
then the ANSI-C interpretation of @samp{\x}.
Otherwise, a literal @samp{X} (used to escape
operators such as @samp{*})

@item \0
a NUL character (ASCII code 0)

@item \123
the character with octal value 123

@item \x2a
the character with hexadecimal value 2a

@item (r)
match an r; parentheses are used to override
                 precedence (see below)

@item rs
the regular expression r followed by the
regular expression s; called @dfn{concatenation}


@item r|s
either an r or an s

@item r/s
an r but only if it is followed by an s.  The
text matched by s is included when determining
whether this rule is the longest match,
but is then returned to the input before
the action is executed.  So the action only
sees the text matched by r.  This type
of pattern is called @dfn{trailing context}.
(There are some combinations of r/s that flex
cannot match correctly. @xref{limitations},
regarding
dangerous trailing context.)

@item ^r
an r, but only at the beginning of a line (i.e.,
when just starting to scan, or right after a
newline has been scanned).

@item r$
an r, but only at the end of a line (i.e., just
before a newline).  Equivalent to @samp{r/\n}.

Note that @code{flex}'s notion of ``newline'' is exactly
whatever the C compiler used to compile @code{flex}
interprets @samp{\n} as; in particular, on some DOS
systems you must either filter out @samp{\r}s in the
input yourself, or explicitly use @samp{r/\r\n} for @samp{r$}.

@item <s>r
an r, but only in start condition s (see
@ref{start conditions} for discussion of start conditions).

@item s1,s2,s3>r
same, but in any of start conditions s1,
s2, or s3.

@item <*>r
an r in any start condition, even an exclusive one.

@item <<EOF>>
an end-of-file.

@item s1,s2>EOF>>
an end-of-file when in start condition s1 or s2
@end table

Note that inside of a character class, all regular expression operators
lose their special meaning except escape (@samp{\}) and the character class
operators, @samp{-}, @samp{]]}, and, at the beginning of the class, @samp{^}.

The regular expressions listed above are grouped according to
precedence, from highest precedence at the top to lowest at the bottom.
Those grouped together have equal precedence.  For example,

@example
@verbatim
    foo|bar*
@end verbatim
@end example

is the same as

@example
@verbatim
    (foo)|(ba(r*))
@end verbatim
@end example

since the '*' operator has higher precedence than concatenation, and
concatenation higher than alternation ('|').  This pattern therefore
matches @emph{either} the string @samp{foo} @emph{or} the string
@samp{ba} followed by zero-or-more r's.  To match @samp{foo} or
zero-or-more repetitions of the string @samp{bar}, use:

@example
@verbatim
    foo|(bar)*
@end verbatim
@end example

And to match a sequence of zero or more repetitions of @samp{foo} and
@samp{bar}:

@example
@verbatim
    (foo|bar)*
@end verbatim
@end example

In addition to characters and ranges of characters, character classes
can also contain @dfn{character class expressions}.  These are
expressions enclosed inside @samp{[}: and @samp{:]} delimiters (which
themselves must appear between the @samp{[} and @samp{]} of the
character class. Other elements may occur inside the character class,
too).  The valid expressions are:

@example
@verbatim
    [:alnum:] [:alpha:] [:blank:]
    [:cntrl:] [:digit:] [:graph:]
    [:lower:] [:print:] [:punct:]
    [:space:] [:upper:] [:xdigit:]
@end verbatim
@end example

These expressions all designate a set of characters equivalent to
the corresponding standard C
@code{isXXX}
function.  For example,
@samp{[:alnum:]}
designates those characters for which
@code{isalnum()}
returns true - i.e., any alphabetic or numeric character.
Some systems don't provide
@code{isblank()},
so flex defines
@samp{[:blank:]}
as a blank or a tab.

For example, the following character classes are all equivalent:

@example
@verbatim
    [[:alnum:]]
    [[:alpha:][:digit:]]
    [[:alpha:][0-9]]
    [a-zA-Z0-9]
@end verbatim
@end example

If your scanner is case-insensitive (the @samp{-i} flag), then
@samp{[:upper:]} and @samp{[:lower:]} are equivalent to
@samp{[:alpha:]}.

Some notes on patterns:

@itemize
@item 
A negated character class such as the example @samp{[^A-Z]}
above
@emph{will match a newline}
unless @samp{\n} (or an equivalent escape sequence) is one of the
characters explicitly present in the negated character class
(e.g., @samp{[^A-Z\n]}).  This is unlike how many other regular
expression tools treat negated character classes, but unfortunately
the inconsistency is historically entrenched.
Matching newlines means that a pattern like @samp{[^"]*} can match the entire
input unless there's another quote in the input.

@item 
A rule can have at most one instance of trailing context (the @samp{/} operator
or the @samp{$} operator).  The start condition, @samp{^}, and @samp{<<EOF>>} patterns
can only occur at the beginning of a pattern, and, as well as with @samp{/} and @samp{$},
cannot be grouped inside parentheses.  A @samp{^} which does not occur at
the beginning of a rule or a @samp{$} which does not occur at the end of
a rule loses its special properties and is treated as a normal character.

@item
The following are illegal:

@example
@verbatim
    foo/bar$
    <sc1>foo<sc2>bar
@end verbatim
@end example

Note that the first of these can be written @samp{foo/bar\n}.

@item
The following will result in @samp{$} or @samp{^} being treated as a normal character:

@example
@verbatim
    foo|(bar$)
    foo|^bar
@end verbatim
@end example

If the desired meaning is a @samp{foo} or a
@samp{bar}-followed-by-a-newline, the following could be used (the
special @code{|} action is explained below, @pxref{actions}):

@example
@verbatim
    foo      |
    bar$     /* action goes here */
@end verbatim
@end example

A similar trick will work for matching a foo or a
bar-at-the-beginning-of-a-line.
@end itemize

@node matching, actions, Patterns, Top
@chapter HOW THE INPUT IS MATCHED

When the generated scanner is run, it analyzes its input looking for
strings which match any of its patterns.  If it finds more than one
match, it takes the one matching the most text (for trailing context
rules, this includes the length of the trailing part, even though it
will then be returned to the input).  If it finds two or more matches of
the same length, the rule listed first in the @code{flex} input file is
chosen.

Once the match is determined, the text corresponding to the match
(called the @dfn{token}) is made available in the global character
pointer @code{yytext}, and its length in the global integer @code{yyleng}.
The @dfn{action} corresponding to the matched pattern is then executed
(@pxref{actions}), and then the remaining input is scanned for another
match.

If no match is found, then the
@dfn{default rule}
is executed: the next character in the input is considered matched and
copied to the standard output.  Thus, the simplest valid
@code{flex}
input is:

@example
@verbatim
    %%
@end verbatim
@end example

which generates a scanner that simply copies its input (one character
at a time) to its output.

Note that @code{yytext} can be defined in two different ways: either as a
character @emph{pointer} or as a character @emph{array}.  You can
control which definition @code{flex} uses by including one of the
special directives @code{%pointer} or @code{%array} in the first
(definitions) section of your flex input.  The default is
@code{%pointer}, unless you use the @samp{-l} lex compatibility option,
in which case @code{yytext} will be an array.  The advantage of using
@code{%pointer} is substantially faster scanning and no buffer overflow
when matching very large tokens (unless you run out of dynamic memory).
The disadvantage is that you are restricted in how your actions can
modify @code{yytext} (@pxref{actions}), and calls to the @code{unput()}
function destroys the present contents of @code{yytext}, which can be a
considerable porting headache when moving between different @code{lex}
versions.

The advantage of
@code{%array}
is that you can then modify
@code{yytext}
to your heart's content, and calls to
@code{unput()}
do not destroy
@code{yytext}
(@pxref{actions}).  Furthermore, existing
@code{lex}
programs sometimes access
@code{yytext}
externally using declarations of the form:

@example
@verbatim
    extern char yytext[];
@end verbatim
@end example

This definition is erroneous when used with @code{%pointer}, but correct
for @code{%array}.

The @code{%array} declaration defines @code{yytext} to be an array of
@code{YYLMAX} characters, which defaults to a fairly large value.  You
can change the size by simply #define'ing @code{YYLMAX} to a different
value in the first section of your @code{flex} input.  As mentioned
above, with @code{%pointer} yytext grows dynamically to accommodate
large tokens.  While this means your @code{%pointer} scanner can
accommodate very large tokens (such as matching entire blocks of
comments), bear in mind that each time the scanner must resize
@code{yytext} it also must rescan the entire token from the beginning, so
matching such tokens can prove slow.  @code{yytext} presently does
@emph{not} dynamically grow if a call to @code{unput()} results in too
much text being pushed back; instead, a run-time error results.

Also note that you cannot use @code{%array} with C++ scanner classes
(@pxref{cxx}).

@node actions, generated scanner, matching, Top
@chapter ACTIONS

Each pattern in a rule has a corresponding action, which can be any
arbitrary C statement.  The pattern ends at the first non-escaped
whitespace character; the remainder of the line is its action.  If the
action is empty, then when the pattern is matched the input token
is simply discarded.  For example, here is the specification for a program
which deletes all occurrences of @samp{zap me} from its input:

@example
@verbatim
    %%
    "zap me"
@end verbatim
@end example

(It will copy all other characters in the input to the output since
they will be matched by the default rule.)

Here is a program which compresses multiple blanks and tabs down to a
single blank, and throws away whitespace found at the end of a line:

@example
@verbatim
    %%
    [ \t]+        putchar( ' ' );
    [ \t]+$       /* ignore this token */
@end verbatim
@end example

If the action contains a @samp{@}}, then the action spans till the balancing @samp{@}}
is found, and the action may cross multiple lines.
@code{flex}
knows about C strings and comments and won't be fooled by braces found
within them, but also allows actions to begin with
@samp{%@{}
and will consider the action to be all the text up to the next
@samp{%@}}
(regardless of ordinary braces inside the action).

An action consisting solely of a vertical bar ('|') means ``same as the
action for the next rule''.  See below for an illustration.

Actions can include arbitrary C code, including @code{return} statements
to return a value to whatever routine called @code{yylex()}.  Each time
@code{yylex()} is called it continues processing tokens from where it
last left off until it either reaches the end of the file or executes a
return.

Actions are free to modify @code{yytext} except for lengthening it
(adding characters to its end--these will overwrite later characters in
the input stream).  This however does not apply when using @code{%array}
(@pxref{matching}). In that case, @code{yytext} may be freely modified in
any way.

Actions are free to modify
@code{yyleng}
except they should not do so if the action also includes use of
@code{yymore()}
(see below).

There are a number of special directives which can be included within
an action:

@table @code
@item  ECHO
copies yytext to the scanner's output.

@item  BEGIN
followed by the name of a start condition places the scanner in the
corresponding start condition (see below).

@item  REJECT
directs the scanner to proceed on to the ``second best'' rule which
matched the input (or a prefix of the input).  The rule is chosen as
described above in @ref{matching}, and @code{yytext} and @code{yyleng} set
up appropriately.  It may either be one which matched as much text as
the originally chosen rule but came later in the @code{flex} input file,
or one which matched less text.  For example, the following will both
count the words in the input and call the routine @code{special()}
whenever @samp{frob} is seen:

@example
@verbatim
            int word_count = 0;
    %%

    frob        special(); REJECT;
    [^ \t\n]+   ++word_count;
@end verbatim
@end example

Without the @code{REJECT}, any occurences of @samp{frob} in the input
would not be counted as words, since the scanner normally executes only
one action per token.  Multiple uses of @code{REJECT} are allowed, each
one finding the next best choice to the currently active rule.  For
example, when the following scanner scans the token @samp{abcd}, it will
write @samp{abcdabcaba} to the output:

@example
@verbatim
    %%
    a        |
    ab       |
    abc      |
    abcd     ECHO; REJECT;
    .|\n     /* eat up any unmatched character */
@end verbatim
@end example

(The first three rules share the fourth's action since they use
the special '|' action.)
@code{REJECT}
is a particularly expensive feature in terms of scanner performance;
if it is used in
@emph{any}
of the scanner's actions it will slow down
@emph{all}
of the scanner's matching.  Furthermore,
@code{REJECT}
cannot be used with the
@samp{-Cf}
or
@samp{-CF}
options (@pxref{invoking flex}).

Note also that unlike the other special actions, @code{REJECT} is a
@emph{branch}.  code immediately following it in the action will
@emph{not} be executed.

@item  yymore()
tells the scanner that the next time it matches a rule, the
corresponding token should be @emph{appended} onto the current value of
@code{yytext} rather than replacing it.  For example, given the input
@samp{mega-kludge} the following will write @samp{mega-mega-kludge} to
the output:

@example
@verbatim
    %%
    mega-    ECHO; yymore();
    kludge   ECHO;
@end verbatim
@end example

First @samp{mega-} is matched and echoed to the output.  Then @samp{kludge}
is matched, but the previous @samp{mega-} is still hanging around at the
beginning of
@code{yytext}
so the
@code{ECHO}
for the @samp{kludge} rule will actually write @samp{mega-kludge}.
@end table

Two notes regarding use of @code{yymore()}.  First, @code{yymore()}
depends on the value of @code{yyleng} correctly reflecting the size of
the current token, so you must not modify @code{yyleng} if you are using
@code{yymore()}.  Second, the presence of @code{yymore()} in the
scanner's action entails a minor performance penalty in the scanner's
matching speed.

@code{yyless(n)} returns all but the first @code{n} characters of the
current token back to the input stream, where they will be rescanned
when the scanner looks for the next match.  @code{yytext} and
@code{yyleng} are adjusted appropriately (e.g., @code{yyleng} will now be
equal to @code{n}).  For example, on the input @samp{foobar} the
following will write out @samp{foobarbar}:

@example
@verbatim
    %%
    foobar    ECHO; yyless(3);
    [a-z]+    ECHO;
@end verbatim
@end example

An argument of 0 to
@code{yyless()}
will cause the entire current input string to be scanned again.  Unless you've
changed how the scanner will subsequently process its input (using
@code{BEGIN},
for example), this will result in an endless loop.

Note that
@code{yyless()}
is a macro and can only be used in the flex input file, not from
other source files.

@code{unput(c)}
puts the character
@code{c}
back onto the input stream.  It will be the next character scanned.
The following action will take the current token and cause it
to be rescanned enclosed in parentheses.

@example
@verbatim
    {
    int i;
    /* Copy yytext because unput() trashes yytext */
    char *yycopy = strdup( yytext );
    unput( ')' );
    for ( i = yyleng - 1; i >= 0; --i )
        unput( yycopy[i] );
    unput( '(' );
    free( yycopy );
    }
@end verbatim
@end example

Note that since each @code{unput()} puts the given character back at the
@emph{beginning} of the input stream, pushing back strings must be done
back-to-front.

An important potential problem when using
@code{unput()}
is that if you are using
@code{%pointer}
(the default), a call to
@code{unput()}
@emph{destroys}
the contents of
@code{yytext},
starting with its rightmost character and devouring one character to
the left with each call.  If you need the value of yytext preserved
after a call to
@code{unput()}
(as in the above example),
you must either first copy it elsewhere, or build your scanner using
@code{%array}
instead (@pxref{matching}).

Finally, note that you cannot put back @samp{EOF} to attempt to mark the
input stream with an end-of-file.

@code{input()} reads the next character from the input stream.  For
example, the following is one way to eat up C comments:

@example
@verbatim
    %%
    "/*"        {
                register int c;

                for ( ; ; )
                    {
                    while ( (c = input()) != '*' &&
                            c != EOF )
                        ;    /* eat up text of comment */

                    if ( c == '*' )
                        {
                        while ( (c = input()) == '*' )
                            ;
                        if ( c == '/' )
                            break;    /* found the end */
                        }

                    if ( c == EOF )
                        {
                        error( "EOF in comment" );
                        break;
                        }
                    }
                }
@end verbatim
@end example

(Note that if the scanner is compiled using @code{C++}, then
@code{input()} is instead referred to as @b{yyinput()}, in order to
avoid a name clash with the @code{C++} stream by the name of
@code{input}.)

@code{YY_FLUSH_BUFFER()}
flushes the scanner's internal buffer
so that the next time the scanner attempts to match a token, it will
first refill the buffer using
@code{YY_INPUT()}
(@pxref{generated scanner}).  This action is a special case
of the more general
@code{yy_flush_buffer()}
function, described below (@pxref{multiple})

@code{yyterminate()}
can be used in lieu of a return statement in an action.  It terminates
the scanner and returns a 0 to the scanner's caller, indicating ``all done''.
By default,
@code{yyterminate()}
is also called when an end-of-file is encountered.  It is a macro and
may be redefined.

@node generated scanner, start conditions, actions, Top
@chapter THE GENERATED SCANNER

The output of @code{flex} is the file @file{lex.yy.c}, which contains
the scanning routine @code{yylex()}, a number of tables used by it for
matching tokens, and a number of auxiliary routines and macros.  By
default, @code{yylex()} is declared as follows:

@example
@verbatim
    int yylex()
        {
        ... various definitions and the actions in here ...
        }
@end verbatim
@end example

(If your environment supports function prototypes, then it will
be
 @code{int yylex( void )}.)  This definition may be changed by defining
the @code{YY_DECL} macro.  For example, you could use:

@example
@verbatim
    #define YY_DECL float lexscan( a, b ) float a, b;
@end verbatim
@end example

to give the scanning routine the name @code{lexscan}, returning a float,
and taking two floats as arguments.  Note that if you give arguments to
the scanning routine using a K&R-style/non-prototyped function
declaration, you must terminate the definition with a semi-colon (;).

Whenever @code{yylex()} is called, it scans tokens from the global input
file @file{yyin} (which defaults to stdin).  It continues until it
either reaches an end-of-file (at which point it returns the value 0) or
one of its actions executes a @code{return} statement.

If the scanner reaches an end-of-file, subsequent calls are undefined
unless either @file{yyin} is pointed at a new input file (in which case
scanning continues from that file), or @code{yyrestart()} is called.
@code{yyrestart()} takes one argument, a @code{FILE *} pointer (which
can be nil, if you've set up @code{YY_INPUT} to scan from a source other
than @code{yyin}), and initializes @file{yyin} for scanning from that
file.  Essentially there is no difference between just assigning
@file{yyin} to a new input file or using @code{yyrestart()} to do so;
the latter is available for compatibility with previous versions of
@code{flex}, and because it can be used to switch input files in the
middle of scanning.  It can also be used to throw away the current input
buffer, by calling it with an argument of @file{yyin}; but it would be
better to use @code{YY_FLUSH_BUFFER} (@pxref{actions}).  Note that
@code{yyrestart()} does @emph{not} reset the start condition to
@code{INITIAL} (@pxref{start conditions}).

If
@code{yylex()}
stops scanning due to executing a
@code{return}
statement in one of the actions, the scanner may then be called again and it
will resume scanning where it left off.

By default (and for purposes of efficiency), the scanner uses
block-reads rather than simple @code{getc()} calls to read characters
from @file{yyin}.  The nature of how it gets its input can be controlled
by defining the @code{YY_INPUT} macro.  The calling sequence for
@code{YY_INPUT()} is @code{YY_INPUT(buf,result,max_size)}.  Its action
is to place up to @code{max_size} characters in the character array
@code{buf} and return in the integer variable @code{result} either the
number of characters read or the constant @code{YY_NULL} (0 on Unix
systems) to indicate @samp{EOF}.  The default @code{YY_INPUT} reads from
the global file-pointer @file{yyin}.

Here is a sample definition of @code{YY_INPUT} (in the definitions
section of the input file):

@example
@verbatim
    %{
    #define YY_INPUT(buf,result,max_size) \
        { \
        int c = getchar(); \
        result = (c == EOF) ? YY_NULL : (buf[0] = c, 1); \
        }
    %}
@end verbatim
@end example

This definition will change the input processing to occur
one character at a time.

When the scanner receives an end-of-file indication from YY_INPUT, it
then checks the @code{yywrap()} function.  If @code{yywrap()} returns
false (zero), then it is assumed that the function has gone ahead and
set up @file{yyin} to point to another input file, and scanning
continues.  If it returns true (non-zero), then the scanner terminates,
returning 0 to its caller.  Note that in either case, the start
condition remains unchanged; it does @emph{not} revert to
@code{INITIAL}.

If you do not supply your own version of @code{yywrap()}, then you must
either use @code{%option noyywrap} (in which case the scanner behaves as
though @code{yywrap()} returned 1), or you must link with @samp{-lfl} to
obtain the default version of the routine, which always returns 1.

Three routines are available for scanning from in-memory buffers rather
than files:
@code{yy_scan_string()}, @code{yy_scan_bytes()},
and
@code{yy_scan_buffer()}.
@xref{multiple}.

The scanner writes its
@code{ECHO}
output to the
@file{yyout}
global (default, @file{stdout}), which may be redefined by the user simply
by assigning it to some other
@code{FILE}
pointer.

@node start conditions, multiple, generated scanner, Top
@chapter START CONDITIONS

@code{flex}
provides a mechanism for conditionally activating rules.  Any rule
whose pattern is prefixed with @samp{<sc>} will only be active when
the scanner is in the start condition named @code{sc}.  For example,

@example
@verbatim
    <STRING>[^"]*        { /* eat up the string body ... */
                ...
                }
@end verbatim
@end example

will be active only when the scanner is in the @code{STRING} start
condition, and

@example
@verbatim
    <INITIAL,STRING,QUOTE>\.        { /* handle an escape ... */
                ...
                }
@end verbatim
@end example

will be active only when the current start condition is either
@code{INITIAL}, @code{STRING}, or @code{QUOTE}.

Start conditions are declared in the definitions (first) section of the
input using unindented lines beginning with either @samp{%s} or
@samp{%x} followed by a list of names.  The former declares
@dfn{inclusive} start conditions, the latter @dfn{exclusive} start
conditions.  A start condition is activated using the @code{BEGIN}
action.  Until the next @code{BEGIN} action is executed, rules with the
given start condition will be active and rules with other start
conditions will be inactive.  If the start condition is inclusive, then
rules with no start conditions at all will also be active.  If it is
exclusive, then @emph{only} rules qualified with the start condition
will be active.  A set of rules contingent on the same exclusive start
condition describe a scanner which is independent of any of the other
rules in the @code{flex} input.  Because of this, exclusive start
conditions make it easy to specify ``mini-scanners'' which scan portions
of the input that are syntactically different from the rest (e.g.,
comments).

If the distinction between inclusive and exclusive start conditions
is still a little vague, here's a simple example illustrating the
connection between the two.  The set of rules:

@example
@verbatim
    %s example
    %%

    <example>foo   do_something();

    bar            something_else();
@end verbatim
@end example

is equivalent to

@example
@verbatim
    %x example
    %%

    <example>foo   do_something();

    <INITIAL,example>bar    something_else();
@end verbatim
@end example

Without the @code{<INITIAL,example>} qualifier, the @code{bar} pattern in
the second example wouldn't be active (i.e., couldn't match) when in
start condition @code{example}.  If we just used @code{example>} to
qualify @code{bar}, though, then it would only be active in
@code{example} and not in @code{INITIAL}, while in the first example
it's active in both, because in the first example the @code{example}
start condition is an inclusive @code{(%s)} start condition.

Also note that the special start-condition specifier
@code{<*>}
matches every start condition.  Thus, the above example could also
have been written:

@example
@verbatim
    %x example
    %%

    <example>foo   do_something();

    <*>bar    something_else();
@end verbatim
@end example

The default rule (to @code{ECHO} any unmatched character) remains active
in start conditions.  It is equivalent to:

@example
@verbatim
    <*>.|\n     ECHO;
@end verbatim
@end example

@code{BEGIN(0)} returns to the original state where only the rules with
no start conditions are active.  This state can also be referred to as
the start-condition @code{INITIAL}, so @code{BEGIN(INITIAL)} is
equivalent to @code{BEGIN(0)}.  (The parentheses around the start
condition name are not required but are considered good style.)

@code{BEGIN} actions can also be given as indented code at the beginning
of the rules section.  For example, the following will cause the scanner
to enter the @code{SPECIAL} start condition whenever @code{yylex()} is
called and the global variable @code{enter_special} is true:

@example
@verbatim
            int enter_special;

    %x SPECIAL
    %%
            if ( enter_special )
                BEGIN(SPECIAL);

    <SPECIAL>blahblahblah
    ...more rules follow...
@end verbatim
@end example

To illustrate the uses of start conditions, here is a scanner which
provides two different interpretations of a string like @samp{123.456}.
By default it will treat it as three tokens, the integer @samp{123}, a
dot (@samp{.}), and the integer @samp{456}.  But if the string is
preceded earlier in the line by the string @samp{expect-floats} it will
treat it as a single token, the floating-point number @samp{123.456}:

@example
@verbatim
    %{
    #include <math.h>
    %}
    %s expect

    %%
    expect-floats        BEGIN(expect);

    <expect>[0-9]+@samp{.}[0-9]+      {
                printf( "found a float, = %f\n",
                        atof( yytext ) );
                }
    <expect>\n           {
                /* that's the end of the line, so
                 * we need another "expect-number"
                 * before we'll recognize any more
                 * numbers
                 */
                BEGIN(INITIAL);
                }

    [0-9]+      {
                printf( "found an integer, = %d\n",
                        atoi( yytext ) );
                }

    "."         printf( "found a dot\n" );
@end verbatim
@end example

Here is a scanner which recognizes (and discards) C comments while
maintaining a count of the current input line.

@example
@verbatim
    %x comment
    %%
            int line_num = 1;

    "/*"         BEGIN(comment);

    <comment>[^*\n]*        /* eat anything that's not a '*' */
    <comment>"*"+[^*/\n]*   /* eat up '*'s not followed by '/'s */
    <comment>\n             ++line_num;
    <comment>"*"+"/"        BEGIN(INITIAL);
@end verbatim
@end example

This scanner goes to a bit of trouble to match as much
text as possible with each rule.  In general, when attempting to write
a high-speed scanner try to match as much possible in each rule, as
it's a big win.

Note that start-conditions names are really integer values and
can be stored as such.  Thus, the above could be extended in the
following fashion:

@example
@verbatim
    %x comment foo
    %%
            int line_num = 1;
            int comment_caller;

    "/*"         {
                 comment_caller = INITIAL;
                 BEGIN(comment);
                 }

    ...

    <foo>"/*"    {
                 comment_caller = foo;
                 BEGIN(comment);
                 }

    <comment>[^*\n]*        /* eat anything that's not a '*' */
    <comment>"*"+[^*/\n]*   /* eat up '*'s not followed by '/'s */
    <comment>\n             ++line_num;
    <comment>"*"+"/"        BEGIN(comment_caller);
@end verbatim
@end example

Furthermore, you can access the current start condition using the
integer-valued @code{YY_START} macro.  For example, the above
assignments to @code{comment_caller} could instead be written

@example
@verbatim
    comment_caller = YY_START;
@end verbatim
@end example

Flex provides @code{YYSTATE} as an alias for @code{YY_START} (since that
is what's used by AT&T @code{lex}).

Note that start conditions do not have their own name-space; %s's and %x's
declare names in the same fashion as #define's.

Finally, here's an example of how to match C-style quoted strings using
exclusive start conditions, including expanded escape sequences (but
not including checking for a string that's too long):

@example
@verbatim
    %x str

    %%
            char string_buf[MAX_STR_CONST];
            char *string_buf_ptr;


    \"      string_buf_ptr = string_buf; BEGIN(str);

    <str>\"        { /* saw closing quote - all done */
            BEGIN(INITIAL);
            *string_buf_ptr = '\0';
            /* return string constant token type and
             * value to parser
             */
            }

    <str>\n        {
            /* error - unterminated string constant */
            /* generate error message */
            }

    <str>\\[0-7]{1,3} {
            /* octal escape sequence */
            int result;

            (void) sscanf( yytext + 1, "%o", &result );

            if ( result > 0xff )
                    /* error, constant is out-of-bounds */

            *string_buf_ptr++ = result;
            }

    <str>\\[0-9]+ {
            /* generate error - bad escape sequence; something
             * like '\48' or '\0777777'
             */
            }

    <str>\\n  *string_buf_ptr++ = '\n';
    <str>\\t  *string_buf_ptr++ = '\t';
    <str>\\r  *string_buf_ptr++ = '\r';
    <str>\\b  *string_buf_ptr++ = '\b';
    <str>\\f  *string_buf_ptr++ = '\f';

    <str>\\(.|\n)  *string_buf_ptr++ = yytext[1];

    <str>[^\\\n\"]+        {
            char *yptr = yytext;

            while ( *yptr )
                    *string_buf_ptr++ = *yptr++;
            }
@end verbatim
@end example

Often, such as in some of the examples above, you wind up writing a
whole bunch of rules all preceded by the same start condition(s).  Flex
makes this a little easier and cleaner by introducing a notion of start
condition @dfn{scope}.  A start condition scope is begun with:

@example
@verbatim
    <SCs>{
@end verbatim
@end example

where @code{SCs} is a list of one or more start conditions.  Inside the
start condition scope, every rule automatically has the prefix
@code{SCs>} applied to it, until a @samp{@}} which matches the initial
@samp{@{}.  So, for example,

@example
@verbatim
    <ESC>{
        "\\n"   return '\n';
        "\\r"   return '\r';
        "\\f"   return '\f';
        "\\0"   return '\0';
    }
@end verbatim
@end example

is equivalent to:

@example
@verbatim
    <ESC>"\\n"  return '\n';
    <ESC>"\\r"  return '\r';
    <ESC>"\\f"  return '\f';
    <ESC>"\\0"  return '\0';
@end verbatim
@end example

Start condition scopes may be nested.

The following routines are available for manipulating stacks of start conditions:

@deftypefun  void yy_push_state ( int @code{new_state} )
pushes the current start condition onto the top of the start condition
stack and switches to
@code{new_state}
as though you had used
@code{BEGIN new_state}
(recall that start condition names are also integers).
@end deftypefun

@deftypefun void yy_pop_state ()
pops the top of the stack and switches to it via
@code{BEGIN}.
@end deftypefun

@deftypefun int yy_top_state ()
returns the top of the stack without altering the stack's contents.
@end deftypefun

The start condition stack grows dynamically and so has no built-in size
limitation.  If memory is exhausted, program execution aborts.

To use start condition stacks, your scanner must include a @code{%option
stack} directive (@pxref{invoking flex}).

@node multiple, eof, start conditions, Top
@chapter MULTIPLE INPUT BUFFERS

Some scanners (such as those which support ``include'' files) require
reading from several input streams.  As @code{flex} scanners do a large
amount of buffering, one cannot control where the next input will be
read from by simply writing a @code{YY_INPUT()} which is sensitive to
the scanning context.  @code{YY_INPUT()} is only called when the scanner
reaches the end of its buffer, which may be a long time after scanning a
statement such as an @code{include} statement which requires switching
the input source.

To negotiate these sorts of problems, @code{flex} provides a mechanism
for creating and switching between multiple input buffers.  An input
buffer is created by using:

@example
@verbatim
    YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
@end verbatim
@end example

which takes a @code{FILE} pointer and a size and creates a buffer
associated with the given file and large enough to hold @code{size}
characters (when in doubt, use @code{YY_BUF_SIZE} for the size).  It
returns a @code{YY_BUFFER_STATE} handle, which may then be passed to
other routines (see below).  The @code{YY_BUFFER_STATE} type is a
pointer to an opaque @code{struct yy_buffer_state} structure, so you may
safely initialize @code{YY_BUFFER_STATE} variables to @code{((YY_BUFFER_STATE)
0)} if you wish, and also refer to the opaque structure in order to
correctly declare input buffers in source files other than that of your
scanner.  Note that the @code{FILE} pointer in the call to
@code{yy_create_buffer} is only used as the value of @file{yyin} seen by
@code{YY_INPUT}.  If you redefine @code{YY_INPUT()} so it no longer uses
@file{yyin}, then you can safely pass a nil @code{FILE} pointer to
@code{yy_create_buffer}.  You select a particular buffer to scan from
using:

@example
@verbatim
    void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
@end verbatim
@end example

The above switches the scanner's input buffer so subsequent tokens will
come from @code{new_buffer}.  Note that @code{yy_switch_to_buffer()} may
be used by @code{yywrap()} to set things up for continued scanning,
instead of opening a new file and pointing @file{yyin} at it.  Note also
that switching input sources via either @code{yy_switch_to_buffer()} or
@code{yywrap()} does @emph{not} change the start condition.

@example
@verbatim
    void yy_delete_buffer( YY_BUFFER_STATE buffer )
@end verbatim
@end example

is used to reclaim the storage associated with a buffer.  (@code{buffer}
can be nil, in which case the routine does nothing.)  You can also clear
the current contents of a buffer using:

@example
@verbatim
    void yy_flush_buffer( YY_BUFFER_STATE buffer )
@end verbatim
@end example

This function discards the buffer's contents,
so the next time the scanner attempts to match a token from the
buffer, it will first fill the buffer anew using
@code{YY_INPUT()}.

@code{yy_new_buffer()} is an alias for @code{yy_create_buffer()},
provided for compatibility with the C++ use of @code{new} and
@code{delete} for creating and destroying dynamic objects.

Finally, the @code{YY_CURRENT_BUFFER} macro returns a
@code{YY_BUFFER_STATE} handle to the current buffer.

Here is an example of using these features for writing a scanner
which expands include files (the
@code{<<EOF>>}
feature is discussed below):

@example
@verbatim
    /* the "incl" state is used for picking up the name
     * of an include file
     */
    %x incl

    %{
    #define MAX_INCLUDE_DEPTH 10
    YY_BUFFER_STATE include_stack[MAX_INCLUDE_DEPTH];
    int include_stack_ptr = 0;
    %}

    %%
    include             BEGIN(incl);

    [a-z]+              ECHO;
    [^a-z\n]*\n?        ECHO;

    <incl>[ \t]*      /* eat the whitespace */
    <incl>[^ \t\n]+   { /* got the include file name */
            if ( include_stack_ptr >= MAX_INCLUDE_DEPTH )
                {
                fprintf( stderr, "Includes nested too deeply" );
                exit( 1 );
                }

            include_stack[include_stack_ptr++] =
                YY_CURRENT_BUFFER;

            yyin = fopen( yytext, "r" );

            if ( ! yyin )
                error( ... );

            yy_switch_to_buffer(
                yy_create_buffer( yyin, YY_BUF_SIZE ) );

            BEGIN(INITIAL);
            }

    <<EOF>> {
            if ( --include_stack_ptr  0 )
                {
                yyterminate();
                }

            else
                {
                yy_delete_buffer( YY_CURRENT_BUFFER );
                yy_switch_to_buffer(
                     include_stack[include_stack_ptr] );
                }
            }
@end verbatim
@end example

The following routines are available for setting up input buffers for
scanning in-memory strings instead of files.  All of them create a new
input buffer for scanning the string, and return a corresponding
@code{YY_BUFFER_STATE} handle (which you should delete with
@code{yy_delete_buffer()} when done with it).  They also switch to the
new buffer using @code{yy_switch_to_buffer()}, so the next call to
@code{yylex()} will start scanning the string.

@deffn Function yy_scan_string ( const char *str )
scans a NUL-terminated string.
@end deffn

@deffn Function yy_scan_bytes ( const char *bytes, int len )
scans @code{len} bytes (including possibly @code{NUL}s) starting at location
@code{bytes}.
@end deffn

Note that both of these functions create and scan a @emph{copy} of the
string or bytes.  (This may be desirable, since @code{yylex()} modifies
the contents of the buffer it is scanning.)  You can avoid the copy by
using:

@deffn yy_scan_buffer char *base, yy_size_t size
which scans in place the buffer starting at @code{base}, consisting of
@code{size} bytes, the last two bytes of which @emph{must} be
@code{YY_END_OF_BUFFER_CHAR} (ASCII NUL).  These last two bytes are not
scanned; thus, scanning consists of @code{base[0]} through
@code{base[size-2]}, inclusive.
@end deffn

If you fail to set up @code{base} in this manner (i.e., forget the final
two @code{YY_END_OF_BUFFER_CHAR} bytes), then @code{yy_scan_buffer()}
returns a nil pointer instead of creating a new input buffer.

The type
@code{yy_size_t}
is an integral type to which you can cast an integer expression
reflecting the size of the buffer.

@node eof, misc macros, multiple, Top
@chapter END-OF-FILE RULES

The special rule @code{<<EOF>>} indicates
actions which are to be taken when an end-of-file is
encountered and @code{yywrap()} returns non-zero (i.e., indicates
no further files to process).  The action must finish
by doing one of the following things:

@itemize
@item 
assigning @file{yyin} to a new input file (in previous versions of
@code{flex}, after doing the assignment you had to call the special
action @code{YY_NEW_FILE}.  This is no longer necessary.)

@item 
executing a @code{return} statement;

@item 
executing the special @code{yyterminate()} action.

@item 
or, switching to a new buffer using @code{yy_switch_to_buffer()} as
shown in the example above.
@end itemize

<<EOF>> rules may not be used with other patterns; they may only be
qualified with a list of start conditions.  If an unqualified <<EOF>>
rule is given, it applies to @emph{all} start conditions which do not
already have <<EOF>> actions.  To specify an <<EOF>> rule for only the
initial start condition, use:

@example
@verbatim
    <INITIAL><<EOF>>
@end verbatim
@end example

These rules are useful for catching things like unclosed comments.  An
example:

@example
@verbatim
    %x quote
    %%

    ...other rules for dealing with quotes...

    <quote><<EOF>>   {
             error( "unterminated quote" );
             yyterminate();
             }
   <<EOF>>  {
             if ( *++filelist )
                 yyin = fopen( *filelist, "r" );
             else
                yyterminate();
             }
@end verbatim
@end example

@node misc macros, user values, eof, Top
@chapter MISCELLANEOUS MACROS

The macro @code{YY_USER_ACTION} can be defined to provide an action
which is always executed prior to the matched rule's action.  For
example, it could be #define'd to call a routine to convert yytext to
lower-case.  When @code{YY_USER_ACTION} is invoked, the variable
@code{yy_act} gives the number of the matched rule (rules are numbered
starting with 1).  Suppose you want to profile how often each of your
rules is matched.  The following would do the trick:

@example
@verbatim
    #define YY_USER_ACTION ++ctr[yy_act]
@end verbatim
@end example

where @code{ctr} is an array to hold the counts for the different rules.
Note that the macro @code{YY_NUM_RULES} gives the total number of rules
(including the default rule), even if you use @samp{-s)}, so a correct
declaration for @code{ctr} is:

@example
@verbatim
    int ctr[YY_NUM_RULES];
@end verbatim
@end example

The macro @code{YY_USER_INIT} may be defined to provide an action which
is always executed before the first scan (and before the scanner's
internal initializations are done).  For example, it could be used to
call a routine to read in a data table or open a logging file.

The macro @code{yy_set_interactive(is_interactive)} can be used to
control whether the current buffer is considered @dfn{interactive}.  An
interactive buffer is processed more slowly, but must be used when the
scanner's input source is indeed interactive to avoid problems due to
waiting to fill buffers (see the discussion of the @samp{-I} flag in
@ref{invoking flex}).  A non-zero value in the macro invocation marks
the buffer as interactive, a zero value as non-interactive.  Note that
use of this macro overrides @code{%option always-interactive} or
@code{%option never-interactive} (@pxref{invoking flex}).
@code{yy_set_interactive()} must be invoked prior to beginning to scan
the buffer that is (or is not) to be considered interactive.

The macro @code{yy_set_bol(at_bol)} can be used to control whether the
current buffer's scanning context for the next token match is done as
though at the beginning of a line.  A non-zero macro argument makes
rules anchored with @samp{^} active, while a zero argument makes
@samp{^} rules inactive.

The macro @code{YY_AT_BOL()} returns true if the next token scanned from
the current buffer will have @samp{^} rules active, false otherwise.

In the generated scanner, the actions are all gathered in one large
switch statement and separated using @code{YY_BREAK}, which may be
redefined.  By default, it is simply a @code{break}, to separate each
rule's action from the following rule's.  Redefining @code{YY_BREAK}
allows, for example, C++ users to #define YY_BREAK to do nothing (while
being very careful that every rule ends with a @code{break}" or a
@code{return}!) to avoid suffering from unreachable statement warnings
where because a rule's action ends with @code{return}, the
@code{YY_BREAK} is inaccessible.

@node user values, yacc, misc macros, Top
@chapter VALUES AVAILABLE TO THE USER

This chapter summarizes the various values available to the user in the
rule actions.

@table @code
@item  char *yytext
holds the text of the current token.  It may be modified but not
lengthened (you cannot append characters to the end).

If the special directive @code{%array} appears in the first section of
the scanner description, then @code{yytext} is instead declared
@code{char yytext[YYLMAX]}, where @code{YYLMAX} is a macro definition
that you can redefine in the first section if you don't like the default
value (generally 8KB).  Using @code{%array} results in somewhat slower
scanners, but the value of @code{yytext} becomes immune to calls to
@code{unput()}, which potentially destroy its value when @code{yytext} is
a character pointer.  The opposite of @code{%array} is @code{%pointer},
which is the default.

You cannot use @code{%array} when generating C++ scanner classes (the
@samp{-+} flag).

@item  int yyleng
holds the length of the current token.

@item  FILE *yyin
is the file which by default @code{flex} reads from.  It may be
redefined but doing so only makes sense before scanning begins or after
an EOF has been encountered.  Changing it in the midst of scanning will
have unexpected results since @code{flex} buffers its input; use
@code{yyrestart()} instead.  Once scanning terminates because an
end-of-file has been seen, you can assign @file{yyin} at the new input
file and then call the scanner again to continue scanning.

@item  void yyrestart( FILE *new_file )
may be called to point @file{yyin} at the new input file.  The
switch-over to the new file is immediate (any previously buffered-up
input is lost).  Note that calling @code{yyrestart()} with @file{yyin}
as an argument thus throws away the current input buffer and continues
scanning the same input file.

@item  FILE *yyout
is the file to which @code{ECHO} actions are done.  It can be reassigned
by the user.

@item  YY_CURRENT_BUFFER
returns a @code{YY_BUFFER_STATE} handle to the current buffer.

@item  YY_START
returns an integer value corresponding to the current start condition.
You can subsequently use this value with @code{BEGIN} to return to that
start condition.
@end table

@node yacc, invoking flex, user values, Top
@chapter INTERFACING WITH YACC

One of the main uses of @code{flex} is as a companion to the @code{yacc}
parser-generator.  @code{yacc} parsers expect to call a routine named
@code{yylex()} to find the next input token.  The routine is supposed to
return the type of the next token as well as putting any associated
value in the global @code{yylval}.  To use @code{flex} with @code{yacc},
one specifies the @samp{-d} option to @code{yacc} to instruct it to
generate the file @file{y.tab.h} containing definitions of all the
@code{%tokens} appearing in the @code{yacc} input.  This file is then
included in the @code{flex} scanner.  For example, if one of the tokens
is @code{TOK_NUMBER}, part of the scanner might look like:

@example
@verbatim
    %{
    #include "y.tab.h"
    %}

    %%

    [0-9]+        yylval = atoi( yytext ); return TOK_NUMBER;
@end verbatim
@end example

@node invoking flex, scanner options, yacc, Top
@chapter Invoking flex

@code{flex}
has the following options:

@table @samp
@item -b
Generate backing-up information to @file{lex.backup}.  This is a list of
scanner states which require backing up and the input characters on
which they do so.  By adding rules one can remove backing-up states.  If
@emph{all} backing-up states are eliminated and @samp{-Cf} or @code{-CF}
is used, the generated scanner will run faster (see the @samp{-p} flag).
Only users who wish to squeeze every last cycle out of their scanners
need worry about this option.  (@pxref{performance}).

@item -c
is a do-nothing option included for POSIX compliance.

@item -d
makes the generated scanner run in @dfn{debug} mode.  Whenever a pattern
is recognized and the global variable @code{yy_flex_debug} is non-zero
(which is the default), the scanner will write to @file{stderr} a line
of the form:

@example
@verbatim
    -accepting rule at line 53 ("the matched text")
@end verbatim
@end example

The line number refers to the location of the rule in the file defining
the scanner (i.e., the file that was fed to flex).  Messages are also
generated when the scanner backs up, accepts the default rule, reaches
the end of its input buffer (or encounters a NUL; at this point, the two
look the same as far as the scanner's concerned), or reaches an
end-of-file.

@item -f
specifies
@dfn{fast scanner}.
No table compression is done and @code{stdio} is bypassed.
The result is large but fast.  This option is equivalent to
@samp{--Cfr}

@item -h
generates a ``help'' summary of @code{flex}'s options to @file{stdout}
and then exits.  @samp{-?}  and @samp{--help} are synonyms for
@samp{-h}.

@item -i
instructs @code{flex} to generate a @dfn{case-insensitive} scanner.  The
case of letters given in the @code{flex} input patterns will be ignored,
and tokens in the input will be matched regardless of case.  The matched
text given in @code{yytext} will have the preserved case (i.e., it will
not be folded).

@item -l
turns on maximum compatibility with the original AT&T @code{lex}
implementation.  Note that this does not mean @emph{full} compatibility.
Use of this option costs a considerable amount of performance, and it
cannot be used with the @samp{-+}, @samp{-f}, @samp{-F}, @samp{-Cf}, or
@samp{-CF} options.  For details on the compatibilities it provides, see
@ref{lex and posix}.  This option also results in the name
@code{YY_FLEX_LEX_COMPAT} being @code{#define}'d in the generated scanner.

@item -n
is another do-nothing option included only for
POSIX compliance.

@item -p
generates a performance report to @file{stderr}.  The report consists of
comments regarding features of the @code{flex} input file which will
cause a serious loss of performance in the resulting scanner.  If you
give the flag twice, you will also get comments regarding features that
lead to minor performance losses.

Note that the use of @code{REJECT}, @code{%option yylineno}, and
variable trailing context (@pxref{limitations}) entails a substantial
performance penalty; use of @code{yymore()}, the @samp{^} operator, and
the @samp{-I} flag entail minor performance penalties.

@item -s
causes the @emph{default rule} (that unmatched scanner input is echoed
to @file{stdout)} to be suppressed.  If the scanner encounters input
that does not match any of its rules, it aborts with an error.  This
option is useful for finding holes in a scanner's rule set.

@item -t
instructs @code{flex} to write the scanner it generates to standard
output instead of @file{lex.yy.c}.

@item -v
specifies that @code{flex} should write to @file{stderr} a summary of
statistics regarding the scanner it generates.  Most of the statistics
are meaningless to the casual @code{flex} user, but the first line
identifies the version of @code{flex} (same as reported by @samp{-V}),
and the next line the flags used when generating the scanner, including
those that are on by default.

@item -w
suppresses warning messages.

@item -B
instructs @code{flex} to generate a @dfn{batch} scanner, the opposite of
@emph{interactive} scanners generated by @samp{-I} (see below).  In
general, you use @samp{-B} when you are @emph{certain} that your scanner
will never be used interactively, and you want to squeeze a
@emph{little} more performance out of it.  If your goal is instead to
squeeze out a @emph{lot} more performance, you should be using the
@samp{-Cf} or @samp{-CF} options, which turn on @samp{-B} automatically
anyway.

@item -F
specifies that the @emph{fast} scanner table representation should be
used (and @code{stdio} bypassed).  This representation is about as fast
as the full table representation @samp{-f}, and for some sets of
patterns will be considerably smaller (and for others, larger).  In
general, if the pattern set contains both @emph{keywords} and a
catch-all, @emph{identifier} rule, such as in the set:

@example
@verbatim
    "case"    return TOK_CASE;
    "switch"  return TOK_SWITCH;
    ...
    "default" return TOK_DEFAULT;
    [a-z]+    return TOK_ID;
@end verbatim
@end example

then you're better off using the full table representation.  If only
the @emph{identifier} rule is present and you then use a hash table or some such
to detect the keywords, you're better off using
@samp{-F}.

This option is equivalent to @samp{-CFr} (see below).  It cannot be used
with @samp{-+}.

@item -I
instructs @code{flex} to generate an @i{interactive} scanner.  An
interactive scanner is one that only looks ahead to decide what token
has been matched if it absolutely must.  It turns out that always
looking one extra character ahead, even if the scanner has already seen
enough text to disambiguate the current token, is a bit faster than only
looking ahead when necessary.  But scanners that always look ahead give
dreadful interactive performance; for example, when a user types a
newline, it is not recognized as a newline token until they enter
@emph{another} token, which often means typing in another whole line.

@code{flex} scanners default to @code{interactive} unless you use the
@samp{-Cf} or @samp{-CF} table-compression options
(@pxref{performance}).  That's because if you're looking for
high-performance you should be using one of these options, so if you
didn't, @code{flex} assumes you'd rather trade off a bit of run-time
performance for intuitive interactive behavior.  Note also that you
@emph{cannot} use @samp{-I} in conjunction with @samp{-Cf} or
@samp{-CF}.  Thus, this option is not really needed; it is on by default
for all those cases in which it is allowed.

You can force a scanner to
@emph{not}
be interactive by using
@samp{-B}

@item -L
instructs
@code{flex}
not to generate
@code{#line}
directives.  Without this option,
@code{flex}
peppers the generated scanner
with @code{#line} directives so error messages in the actions will be correctly
located with respect to either the original
@code{flex}
input file (if the errors are due to code in the input file), or
@file{lex.yy.c}
(if the errors are
@code{flex}'s
fault -- you should report these sorts of errors to the email address
given in @ref{reporting bugs}).

@item -R
instructs flex to generate a reentrant C scanner.  The generated scanner
may safely be used in a multi-threaded environment. The API for a
reentrant scanner is different than for a non-reentrant scanner
@pxref{reentrant}).  Because of the API difference between
reentrant and non-reentrant @code{flex} scanners, non-reentrant flex
code must be modified before it is suitable for use with this option.
This option is not compatible with the @samp{-+} option.

@item -Rb
instructs flex to generate a reentrant C scanner that is
meant to be called by a
@code{GNU bison}
pure parser. The scanner is the same as the scanner generated by the
@samp{-R}
option, but with minor API changes for
@code{bison}
compatibility. In particular, the declaration of
@code{yylex}
is modified, and support for
@code{yylval_r}
and
@code{yylloc_r}
is incorporated. @xref{bison pure}.

The options @samp{-R} and @samp{-Rb} do not affect the performance of
the scanner.

@item -T
makes @code{flex} run in @dfn{trace} mode.  It will generate a lot of
messages to @file{stderr} concerning the form of the input and the
resultant non-deterministic and deterministic finite automata.  This
option is mostly for use in maintaining @code{flex}.

@item -V
prints the version number to @file{stdout} and exits.  @samp{--version}
is a synonym for @samp{-V}.

@item -7
instructs @code{flex} to generate a 7-bit scanner, i.e., one which can
only recognize 7-bit characters in its input.  The advantage of using
@samp{-7} is that the scanner's tables can be up to half the size of
those generated using the @samp{-8}.  The disadvantage is that such
scanners often hang or crash if their input contains an 8-bit character.

Note, however, that unless you generate your scanner using the
@samp{-Cf} or @samp{-CF} table compression options, use of @samp{-7}
will save only a small amount of table space, and make your scanner
considerably less portable.  @code{Flex}'s default behavior is to
generate an 8-bit scanner unless you use the @samp{-Cf} or @samp{-CF},
in which case @code{flex} defaults to generating 7-bit scanners unless
your site was always configured to generate 8-bit scanners (as will
often be the case with non-USA sites).  You can tell whether flex
generated a 7-bit or an 8-bit scanner by inspecting the flag summary in
the @samp{-v} output as described above.

Note that if you use @samp{-Cfe} or @samp{-CFe} @code{flex} still
defaults to generating an 8-bit scanner, since usually with these
compression options full 8-bit tables are not much more expensive than
7-bit tables.

@item -8
instructs @code{flex} to generate an 8-bit scanner, i.e., one which can
recognize 8-bit characters.  This flag is only needed for scanners
generated using @samp{-Cf} or @samp{-CF}, as otherwise flex defaults to
generating an 8-bit scanner anyway.

See the discussion of
@samp{-7}
above for @code{flex}'s default behavior and the tradeoffs between 7-bit
and 8-bit scanners.

@item -+
specifies that you want flex to generate a C++
scanner class.  @xref{cxx}, for
details.

@item -C[aefFmr]
controls the degree of table compression and, more generally, trade-offs
between small scanners and fast scanners.

@item -Ca
(``align'') instructs flex to trade off larger tables in the
generated scanner for faster performance because the elements of
the tables are better aligned for memory access and computation.  On some
RISC architectures, fetching and manipulating longwords is more efficient
than with smaller-sized units such as shortwords.  This option can
double the size of the tables used by your scanner.

@item -Ce
directs @code{flex} to construct @dfn{equivalence classes}, i.e., sets
of characters which have identical lexical properties (for example, if
the only appearance of digits in the @code{flex} input is in the
character class ``[0-9]'' then the digits '0', '1', ..., '9' will all be
put in the same equivalence class).  Equivalence classes usually give
dramatic reductions in the final table/object file sizes (typically a
factor of 2-5) and are pretty cheap performance-wise (one array look-up
per character scanned).

@item -Cf
specifies that the @dfn{full} scanner tables should be generated -
@code{flex} should not compress the tables by taking advantages of
similar transition functions for different states.

@item -CF
specifies that the alternate fast scanner representation (described
above under the @samp{-F} flag) should be used.  This option cannot be
used with @samp{-+}.

@item -Cm
directs
@code{flex}
to construct
@dfn{meta-equivalence classes},
which are sets of equivalence classes (or characters, if equivalence
classes are not being used) that are commonly used together.  Meta-equivalence
classes are often a big win when using compressed tables, but they
have a moderate performance impact (one or two @code{if} tests and one
array look-up per character scanned).

@item -Cr
causes the generated scanner to @emph{bypass} use of the standard I/O
library (@code{stdio}) for input.  Instead of calling @code{fread()} or
@code{getc()}, the scanner will use the @code{read()} system call,
resulting in a performance gain which varies from system to system, but
in general is probably negligible unless you are also using @samp{-Cf}
or @samp{-CF}.  Using @samp{-Cr} can cause strange behavior if, for
example, you read from @file{yyin} using @code{stdio} prior to calling
the scanner (because the scanner will miss whatever text your previous
reads left in the @code{stdio} input buffer).  @samp{-Cr} has no effect
if you define @code{YY_INPUT()} (@pxref{generated scanner}).

@item -C
A lone @samp{-C} specifies that the scanner tables should be compressed
but neither equivalence classes nor meta-equivalence classes should be
used.

The options @samp{-Cf} or @samp{-CF} and @samp{-Cm} do not make sense
together - there is no opportunity for meta-equivalence classes if the
table is not being compressed.  Otherwise the options may be freely
mixed, and are cumulative.

The default setting is @samp{-Cem}, which specifies that @code{flex}
should generate equivalence classes and meta-equivalence classes.  This
setting provides the highest degree of table compression.  You can trade
off faster-executing scanners at the cost of larger tables with the
following generally being true:

@example
@verbatim
    slowest & smallest
          -Cem
          -Cm
          -Ce
          -C
          -C{f,F}e
          -C{f,F}
          -C{f,F}a
    fastest & largest
@end verbatim
@end example

Note that scanners with the smallest tables are usually generated and
compiled the quickest, so during development you will usually want to
use the default, maximal compression.

@samp{-Cfe} is often a good compromise between speed and size for
production scanners.

@item -ooutput
directs flex to write the scanner to the file @file{output} instead of
@file{lex.yy.c}.  If you combine @samp{-o} with the @samp{-t} option,
then the scanner is written to @file{stdout} but its @code{#line}
directives (see the @samp{-l} option above) refer to the file
@file{output}.

@item -Pprefix
changes the default @samp{yy} prefix used by @code{flex} for all
globally-visible variable and function names to instead be
@samp{prefix}.  For example, @samp{-Pfoo} changes the name of
@code{yytext} to @code{footext}.  It also changes the name of the default
output file from @file{lex.yy.c} to @file{lex.foo.c}.  Here are all of
the names affected:

@example
@verbatim
    yy_create_buffer
    yy_delete_buffer
    yy_flex_debug
    yy_init_buffer
    yy_flush_buffer
    yy_load_buffer_state
    yy_switch_to_buffer
    yyin
    yyleng
    yylex
    yylineno
    yyout
    yyrestart
    yytext
    yywrap
@end verbatim
@end example

(If you are using a C++ scanner, then only @code{yywrap} and
@code{yyFlexLexer} are affected.)  Within your scanner itself, you can
still refer to the global variables and functions using either version
of their name; but externally, they have the modified name.

This option lets you easily link together multiple
@code{flex}
programs into the same executable.  Note, though, that using this
option also renames
@code{yywrap()},
so you now
@emph{must}
either
provide your own (appropriately-named) version of the routine for your
scanner, or use
@code{%option noyywrap},
as linking with
@samp{-lfl}
no longer provides one for you by default.

@item -Sskeleton_file
overrides the default skeleton file from which
@code{flex}
constructs its scanners.  You'll never need this option unless you are doing
@code{flex}
maintenance or development.
@end table

@node scanner options, performance, invoking flex, Top
@chapter option Directives within Scanners

@code{flex} also provides a mechanism for controlling options within the
scanner specification itself, rather than from the flex command-line.
This is done by including @code{%option} directives in the first section
of the scanner specification.  You can specify multiple options with a
single @code{%option} directive, and multiple directives in the first
section of your flex input file.

Most options are given simply as names, optionally preceded by the
word @samp{no} (with no intervening whitespace) to negate their meaning.
A number are equivalent to flex flags or their negation:

@example
@verbatim
    7bit            -7 option
    8bit            -8 option
    align           -Ca option
    backup          -b option
    batch           -B option
    c++             -+ option

    caseful or
    case-sensitive  opposite of -i (default)

    case-insensitive or
    caseless        -i option

    debug           -d option
    default         opposite of -s option
    ecs             -Ce option
    fast            -F option
    full            -f option
    interactive     -I option
    lex-compat      -l option
    meta-ecs        -Cm option
    perf-report     -p option
    read            -Cr option
    reentrant       -R option
    rentrant-bison  -Rb option
    stdout          -t option
    verbose         -v option
    warn            opposite of -w option
                    (use "%option nowarn" for -w)

    array           equivalent to "%array"
    pointer         equivalent to "%pointer" (default)
@end verbatim
@end example

Some @code{%option}'s provide features otherwise not available:

@table @code
@item always-interactive
instructs flex to generate a scanner which always considers its input
@emph{interactive}.  Normally, on each new input file the scanner calls
@code{isatty()} in an attempt to determine whether the scanner's input
source is interactive and thus should be read a character at a time.
When this option is used, however, then no such call is made.

@item main
 directs flex to provide a default @code{main()} program for the
scanner, which simply calls @code{yylex()}.  This option implies
@code{noyywrap} (see below).

@item never-interactive
instructs flex to generate a scanner which never considers its input
interactive.  This is the opposite of @code{always-interactive}.

@item stack
enables the use of
start condition stacks (@pxref{start conditions}).  

@item stdinit
if set (i.e., @b{%option stdinit)} initializes @code{yyin} and
@code{yyout} to @file{stdin} and @file{stdout}, instead of the default of
@file{nil}.  Some existing @code{lex} programs depend on this behavior,
even though it is not compliant with ANSI C, which does not require
@file{stdin} and @file{stdout} to be compile-time constant. In a
reentrant scanner, however, this is not a problem since initialization
is performed in @code{yylex_init} at runtime.

@item yylineno
directs @code{flex} to generate a scanner
that maintains the number of the current line read from its input in the
global variable @code{yylineno}.  This option is implied by @code{%option
lex-compat}.  In a reentrant C scanner, the macro @code{yylineno_r} is
accessible regardless of the value of @code{%option yylineno}, however, its
value is not modified by @code{flex} unless @code{%option yylineno} is enabled.

@item yywrap
if unset (i.e., @code{%option noyywrap)}, makes the scanner not call
@code{yywrap()} upon an end-of-file, but simply assume that there are no
more files to scan (until the user points @file{yyin} at a new file and
calls @code{yylex()} again).
@end table

@code{flex} scans your rule actions to determine whether you use the
@code{REJECT} or @code{yymore()} features.  The @code{REJECT} and
@code{yymore} options are available to override its decision as to
whether you use the options, either by setting them (e.g., @code{%option
reject)} to indicate the feature is indeed used, or unsetting them to
indicate it actually is not used (e.g., @code{%option noyymore)}.

These options take string-delimited values, offset with '=':

@example
@verbatim
    %option outfile="ABC"
@end verbatim
@end example

is equivalent to @samp{-oABC}, and

@example
@verbatim
    %option prefix="XYZ"
@end verbatim
@end example

is equivalent to @samp{-PXYZ}.

Finally,

@example
@verbatim
    %option yyclass="foo"
@end verbatim
@end example

only applies when generating a C++ scanner (the @samp{-+} option).  It
informs @code{flex} that you have derived @code{foo} as a subclass of
@code{yyFlexLexer}, so @code{flex} will place your actions in the member
function @code{foo::yylex()} instead of @code{yyFlexLexer::yylex()}.  It
also generates a @code{yyFlexLexer::yylex()} member function that emits
a run-time error (by invoking @code{yyFlexLexer::LexerError())} if
called.  @xref{cxx}.

A number of options are available for lint purists who want to suppress
the appearance of unneeded routines in the generated scanner.  Each of
the following, if unset (e.g., @code{%option nounput}), results in the
corresponding routine not appearing in the generated scanner:

@example
@verbatim
    input, unput
    yy_push_state, yy_pop_state, yy_top_state
    yy_scan_buffer, yy_scan_bytes, yy_scan_string

    yyget_extra, yyset_extra, yyget_leng, yyget_text, 
    yyget_lineno, yyset_lineno, yyget_in, yyset_in,
    yyget_out, yyset_out, yyget_lval, yyset_lval,
    yyget_lloc, yyset_lloc,
@end verbatim
@end example

(though @code{yy_push_state()} and friends won't appear anyway unless
you use @code{%option stack)}.

@node performance, cxx, scanner options, Top
@chapter PERFORMANCE CONSIDERATIONS

The main design goal of @code{flex} is that it generate high-performance
scanners.  It has been optimized for dealing well with large sets of
rules.  Aside from the effects on scanner speed of the table compression
@samp{-C} options outlined above, there are a number of options/actions
which degrade performance.  These are, from most expensive to least:

@example
@verbatim
    REJECT
    %option yylineno
    arbitrary trailing context

    pattern sets that require backing up
    %array
    %option interactive
    %option always-interactive

    @samp{^} beginning-of-line operator
    yymore()
@end verbatim
@end example

with the first three all being quite expensive and the last two being
quite cheap.  Note also that @code{unput()} is implemented as a routine
call that potentially does quite a bit of work, while @code{yyless()} is
a quite-cheap macro. So if you are just putting back some excess text
you scanned, use @code{ss()}.

@code{REJECT} should be avoided at all costs when performance is
important.  It is a particularly expensive option.

Getting rid of backing up is messy and often may be an enormous amount
of work for a complicated scanner.  In principal, one begins by using
the @samp{-b} flag to generate a @file{lex.backup} file.  For example,
on the input:

@example
@verbatim
    %%
    foo        return TOK_KEYWORD;
    foobar     return TOK_KEYWORD;
@end verbatim
@end example

the file looks like:

@example
@verbatim
    State #6 is non-accepting -
     associated rule line numbers:
           2       3
     out-transitions: [ o ]
     jam-transitions: EOF [ \001-n  p-\177 ]

    State #8 is non-accepting -
     associated rule line numbers:
           3
     out-transitions: [ a ]
     jam-transitions: EOF [ \001-`  b-\177 ]

    State #9 is non-accepting -
     associated rule line numbers:
           3
     out-transitions: [ r ]
     jam-transitions: EOF [ \001-q  s-\177 ]

    Compressed tables always back up.
@end verbatim
@end example

The first few lines tell us that there's a scanner state in which it can
make a transition on an 'o' but not on any other character, and that in
that state the currently scanned text does not match any rule.  The
state occurs when trying to match the rules found at lines 2 and 3 in
the input file.  If the scanner is in that state and then reads
something other than an 'o', it will have to back up to find a rule
which is matched.  With a bit of headscratching one can see that this
must be the state it's in when it has seen @samp{fo}.  When this has
happened, if anything other than another @samp{o} is seen, the scanner
will have to back up to simply match the @samp{f} (by the default rule).

The comment regarding State #8 indicates there's a problem when
@samp{foob} has been scanned.  Indeed, on any character other than an
@samp{a}, the scanner will have to back up to accept "foo".  Similarly,
the comment for State #9 concerns when @samp{fooba} has been scanned and
an @samp{r} does not follow.

The final comment reminds us that there's no point going to all the
trouble of removing backing up from the rules unless we're using
@samp{-Cf} or @samp{-CF}, since there's no performance gain doing so
with compressed scanners.

The way to remove the backing up is to add ``error'' rules:

@example
@verbatim
    %%
    foo         return TOK_KEYWORD;
    foobar      return TOK_KEYWORD;

    fooba       |
    foob        |
    fo          {
                /* false alarm, not really a keyword */
                return TOK_ID;
                }
@end verbatim
@end example

Eliminating backing up among a list of keywords can also be done using a
``catch-all'' rule:

@example
@verbatim
    %%
    foo         return TOK_KEYWORD;
    foobar      return TOK_KEYWORD;

    [a-z]+      return TOK_ID;
@end verbatim
@end example

This is usually the best solution when appropriate.

Backing up messages tend to cascade.  With a complicated set of rules
it's not uncommon to get hundreds of messages.  If one can decipher
them, though, it often only takes a dozen or so rules to eliminate the
backing up (though it's easy to make a mistake and have an error rule
accidentally match a valid token.  A possible future @code{flex} feature
will be to automatically add rules to eliminate backing up).

It's important to keep in mind that you gain the benefits of eliminating
backing up only if you eliminate @emph{every} instance of backing up.
Leaving just one means you gain nothing.

@emph{Variable} trailing context (where both the leading and trailing
parts do not have a fixed length) entails almost the same performance
loss as @code{REJECT} (i.e., substantial).  So when possible a rule
like:

@example
@verbatim
    %%
    mouse|rat/(cat|dog)   run();
@end verbatim
@end example

is better written:

@example
@verbatim
    %%
    mouse/cat|dog         run();
    rat/cat|dog           run();
@end verbatim
@end example

or as

@example
@verbatim
    %%
    mouse|rat/cat         run();
    mouse|rat/dog         run();
@end verbatim
@end example

Note that here the special '|' action does @emph{not} provide any
savings, and can even make things worse (@pxref{limitations}).

Another area where the user can increase a scanner's performance (and
one that's easier to implement) arises from the fact that the longer the
tokens matched, the faster the scanner will run.  This is because with
long tokens the processing of most input characters takes place in the
(short) inner scanning loop, and does not often have to go through the
additional work of setting up the scanning environment (e.g.,
@code{yytext}) for the action.  Recall the scanner for C comments:

@example
@verbatim
    %x comment
    %%
            int line_num = 1;

    "/*"         BEGIN(comment);

    <comment>[^*\n]*
    <comment>"*"+[^*/\n]*
    <comment>\n             ++line_num;
    <comment>"*"+"/"        BEGIN(INITIAL);
@end verbatim
@end example

This could be sped up by writing it as:

@example
@verbatim
    %x comment
    %%
            int line_num = 1;

    "/*"         BEGIN(comment);

    <comment>[^*\n]*
    <comment>[^*\n]*\n      ++line_num;
    <comment>"*"+[^*/\n]*
    <comment>"*"+[^*/\n]*\n ++line_num;
    <comment>"*"+"/"        BEGIN(INITIAL);
@end verbatim
@end example

Now instead of each newline requiring the processing of another action,
recognizing the newlines is distributed over the other rules to keep the
matched text as long as possible.  Note that @emph{adding} rules does
@emph{not} slow down the scanner!  The speed of the scanner is
independent of the number of rules or (modulo the considerations given
at the beginning of this section) how complicated the rules are with
regard to operators such as @samp{*} and @samp{|}.

A final example in speeding up a scanner: suppose you want to scan
through a file containing identifiers and keywords, one per line
and with no other extraneous characters, and recognize all the
keywords.  A natural first approach is:

@example
@verbatim
    %%
    asm      |
    auto     |
    break    |
    ... etc ...
    volatile |
    while    /* it's a keyword */

    .|\n     /* it's not a keyword */
@end verbatim
@end example

To eliminate the back-tracking, introduce a catch-all rule:

@example
@verbatim
    %%
    asm      |
    auto     |
    break    |
    ... etc ...
    volatile |
    while    /* it's a keyword */

    [a-z]+   |
    .|\n     /* it's not a keyword */
@end verbatim
@end example

Now, if it's guaranteed that there's exactly one word per line, then we
can reduce the total number of matches by a half by merging in the
recognition of newlines with that of the other tokens:

@example
@verbatim
    %%
    asm\n    |
    auto\n   |
    break\n  |
    ... etc ...
    volatile\n |
    while\n  /* it's a keyword */

    [a-z]+\n |
    .|\n     /* it's not a keyword */
@end verbatim
@end example

One has to be careful here, as we have now reintroduced backing up
into the scanner.  In particular, while
@emph{we}
know that there will never be any characters in the input stream
other than letters or newlines,
@code{flex}
can't figure this out, and it will plan for possibly needing to back up
when it has scanned a token like @samp{auto} and then the next character
is something other than a newline or a letter.  Previously it would
then just match the @samp{auto} rule and be done, but now it has no @samp{auto}
rule, only a @samp{auto\n} rule.  To eliminate the possibility of backing up,
we could either duplicate all rules but without final newlines, or,
since we never expect to encounter such an input and therefore don't
how it's classified, we can introduce one more catch-all rule, this
one which doesn't include a newline:

@example
@verbatim
    %%
    asm\n    |
    auto\n   |
    break\n  |
    ... etc ...
    volatile\n |
    while\n  /* it's a keyword */

    [a-z]+\n |
    [a-z]+   |
    .|\n     /* it's not a keyword */
@end verbatim
@end example

Compiled with @samp{-Cf}, this is about as fast as one can get a
@code{flex} scanner to go for this particular problem.

A final note: @code{flex} is slow when matching @code{NUL}s,
particularly when a token contains multiple @code{NUL}s.  It's best to
write rules which match @emph{short} amounts of text if it's anticipated
that the text will often include @code{NUL}s.

Another final note regarding performance: as mentioned in
@ref{matching}, dynamically resizing @code{yytext} to accommodate huge
tokens is a slow process because it presently requires that the (huge)
token be rescanned from the beginning.  Thus if performance is vital,
you should attempt to match ``large'' quantities of text but not
``huge'' quantities, where the cutoff between the two is at about 8K
characters per token.

@node cxx, reentrant, performance, Top
@chapter GENERATING C++ SCANNERS

@code{flex} provides two different ways to generate scanners for use
with C++.  The first way is to simply compile a scanner generated by
@code{flex} using a C++ compiler instead of a C compiler.  You should
not encounter any compilation errors (@pxref{reporting bugs}).  You can
then use C++ code in your rule actions instead of C code.  Note that the
default input source for your scanner remains @file{yyin}, and default
echoing is still done to @file{yyout}.  Both of these remain @code{FILE
*} variables and not C++ @emph{streams}.

You can also use @code{flex} to generate a C++ scanner class, using the
@samp{-+} option (or, equivalently, @code{%option c++)}, which is
automatically specified if the name of the @code{flex} executable ends
in a '+', such as @code{flex++}.  When using this option, @code{flex}
defaults to generating the scanner to the file @file{lex.yy.cc} instead
of @file{lex.yy.c}.  The generated scanner includes the header file
@file{FlexLexer.h}, which defines the interface to two C++ classes.

The first class,
@code{FlexLexer},
provides an abstract base class defining the general scanner class
interface.  It provides the following member functions:

@table @code
@item const char* YYText()
returns the text of the most recently matched token, the equivalent of
@code{yytext}.

@item int YYLeng()
returns the length of the most recently matched token, the equivalent of
@code{yyleng}.

@item int lineno() const
returns the current input line number (see @code{%option yylineno)}, or
@code{1} if @code{%option yylineno} was not used.

@item void set_debug( int flag )
sets the debugging flag for the scanner, equivalent to assigning to
@code{yy_flex_debug} (@pxref{invoking flex}).  Note that you must build
the scannerusing @code{%option debug} to include debugging information
in it.

@item int debug() const
returns the current setting of the debugging flag.
@end table

Also provided are member functions equivalent to
@code{yy_switch_to_buffer()}, @code{yy_create_buffer()} (though the
first argument is an @code{istream*} object pointer and not a
@code{FILE*)}, @code{yy_flush_buffer()}, @code{yy_delete_buffer()}, and
@code{yyrestart()} (again, the first argument is a @code{istream*}
object pointer).

The second class defined in @file{FlexLexer.h} is @code{yyFlexLexer},
which is derived from @code{FlexLexer}.  It defines the following
additional member functions:

@table @code
@item yyFlexLexer( istream* arg_yyin = 0, ostream* arg_yyout = 0 )
constructs a @code{yyFlexLexer} object using the given streams for input
and output.  If not specified, the streams default to @code{cin} and
@code{cout}, respectively.

@item virtual int yylex()
performs the same role is @code{yylex()} does for ordinary @code{flex}
scanners: it scans the input stream, consuming tokens, until a rule's
action returns a value.  If you derive a subclass @code{S} from
@code{yyFlexLexer} and want to access the member functions and variables
of @code{S} inside @code{yylex()}, then you need to use @code{%option
yyclass="S"} to inform @code{flex} that you will be using that subclass
instead of @code{yyFlexLexer}.  In this case, rather than generating
@code{yyFlexLexer::yylex()}, @code{flex} generates @code{S::yylex()}
(and also generates a dummy @code{yyFlexLexer::yylex()} that calls
@code{yyFlexLexer::LexerError()} if called).

@item virtual void switch_streams(istream* new_in = 0, ostream* new_out = 0)
reassigns @code{yyin} to @code{new_in} (if non-nil) and @code{yyout} to
@code{new_out} (if non-nil), deleting the previous input buffer if
@code{yyin} is reassigned.

@item int yylex( istream* new_in, ostream* new_out = 0 )
first switches the input streams via @code{switch_streams( new_in,
new_out )} and then returns the value of @code{yylex()}.
@end table

In addition, @code{yyFlexLexer} defines the following protected virtual
functions which you can redefine in derived classes to tailor the
scanner:

@table @code
@item virtual int LexerInput( char* buf, int max_size )
reads up to @code{max_size} characters into @code{buf} and returns the
number of characters read.  To indicate end-of-input, return 0
characters.  Note that @code{interactive} scanners (see the @samp{-B}
and @samp{-I} flags in @ref{invoking flex}) define the macro
@code{YY_INTERACTIVE}.  If you redefine @code{LexerInput()} and need to
take different actions depending on whether or not the scanner might be
scanning an interactive input source, you can test for the presence of
this name via @code{#ifdef} statements.

@item virtual void LexerOutput( const char* buf, int size )
writes out @code{size} characters from the buffer @code{buf}, which, while
@code{NUL}-terminated, may also contain internal @code{NUL}s if the
scanner's rules can match text with @code{NUL}s in them.

@item virtual void LexerError( const char* msg )
reports a fatal error message.  The default version of this function
writes the message to the stream @code{cerr} and exits.
@end table

Note that a @code{yyFlexLexer} object contains its @emph{entire}
scanning state.  Thus you can use such objects to create reentrant
scanners.  You can instantiate multiple instances of the same
@code{yyFlexLexer} class, and you can also combine multiple C++ scanner
classes together in the same program using the @samp{-P} option
discussed above.

Finally, note that the @code{%array} feature is not available to C++
scanner classes; you must use @code{%pointer} (the default).

Here is an example of a simple C++ scanner:

@example
@verbatim
        // An example of using the flex C++ scanner class.

    %{
    int mylineno = 0;
    %}

    string  \"[^\n"]+\"

    ws      [ \t]+

    alpha   [A-Za-z]
    dig     [0-9]
    name    ({alpha}|{dig}|\$)({alpha}|{dig}|[_.\-/$])*
    num1    [-+]?{dig}+\.?([eE][-+]?{dig}+)?
    num2    [-+]?{dig}*\.{dig}+([eE][-+]?{dig}+)?
    number  {num1}|{num2}

    %%

    {ws}    /* skip blanks and tabs */

    "/*"    {
            int c;

            while((c = yyinput()) != 0)
                {
                if(c == '\n')
                    ++mylineno;

                else if(c == @samp{*})
                    {
                    if((c = yyinput()) == '/')
                        break;
                    else
                        unput(c);
                    }
                }
            }

    {number}  cout  "number "  YYText()  '\n';

    \n        mylineno++;

    {name}    cout  "name "  YYText()  '\n';

    {string}  cout  "string "  YYText()  '\n';

    %%

    int main( int /* argc */, char** /* argv */ )
        {
        @code{flex}Lexer* lexer = new yyFlexLexer;
        while(lexer->yylex() != 0)
            ;
        return 0;
        }
@end verbatim
@end example

If you want to create multiple (different) lexer classes, you use the
@samp{-P} flag (or the @code{prefix=} option) to rename each
@code{yyFlexLexer} to some other @samp{xxFlexLexer}.  You then can
include @file{FlexLexer.h>} in your other sources once per lexer class,
first renaming @code{yyFlexLexer} as follows:

@example
@verbatim
    #undef yyFlexLexer
    #define yyFlexLexer xxFlexLexer
    #include <FflexLexer.h>

    #undef yyFlexLexer
    #define yyFlexLexer zzFlexLexer
    #include FlexLexer.h>
@end verbatim
@end example

if, for example, you used @code{%option prefix="xx"} for one of your
scanners and @code{%option prefix="zz"} for the other.

IMPORTANT: the present form of the scanning class is @emph{experimental}
and may change considerably between major releases.

@node reentrant, lex and posix, cxx, Top
@chapter REENTRANT C SCANNERS

@code{flex} has the ability to generate a reentrant C scanner. This is
accomplished by specifying @code{%option reentrant} (@samp{-R}) or
@code{%option reentrant-bison} (@samp{-Rb}).  The generated scanner is
both portable, and safe to use in one or more separate threads of
control.  The most common use for reentrant scanners is from within
multi-threaded applications.  Any thread may create and execute a
reentrant @code{flex} scanner without the need for synchronization with
other threads.

@menu
* reentrant uses::              
* reentrant overview::          
* reentrant example::           
* reentrant detail::            
* bison pure::                  
* reentrant functions::         
@end menu

@node reentrant uses, reentrant overview, reentrant, reentrant
@section Uses for Reentrant Scanners

However, there are other uses for a reentrant scanner.  For example, you
could scan two or more files simultaneously to implement a @code{diff} at
the token level (i.e., instead of at the character level):

@example
@verbatim
    /* Example of maintaining more than one active scanner. */

    do {
        int tok1, tok2;

        tok1 = yylex( scanner_1 );
        tok2 = yylex( scanner_2 );

        if( tok1 != tok2 )
            printf("Files are different.");

   } while ( tok1 && tok2 );
@end verbatim
@end example

Another use for a reentrant scanner is recursion.
(Note that a recursive scanner can also be created using a non-reentrant scanner and
buffer states. @xref{multiple}.)

The following crude scanner supports the @samp{eval} command by invoking
another instance of itself.

@example
@verbatim
    /* Example of recursive invocation. */

    %option reentrant

    %%
    "eval(".+")"  {  
                      void * scanner;
                      yylex_init( &scanner );
                      yytext_r[yyleng_r-1] = ' '; 

                      yyscan_string( yytext_r + 5, scanner );
                      yylex( scanner );

                      yylex_destroy( scanner );
                 }
    ...
    %%
@end verbatim
@end example

@node reentrant overview, reentrant example, reentrant uses, reentrant
@section An overview of the reentrant API

The API for reentrant scanners is different than for non-reentrant
scanners. Here is a quick overview of the API:

@itemize
@code{%option reentrant} must be specified.

@item
All functions take one additional argument: @code{yy_globals}

@item
All global variables are replaced by their @samp{_r} equivalents.

@item
@code{yylex_init} and @code{yylex_destroy} must be called before and
after @code{yylex}, respectively.

@item 
Accessor methods (get/set functions) provide access to common
@code{flex} variables.

@item 
User-specific data can be stored in @code{yyextra_r}.
@end itemize

@node reentrant example, reentrant detail, reentrant overview, reentrant
@section Reentrant Example

First, an example of a reentrant scanner:

@example
@verbatim
    /* This scanner prints "//" comments. */
    %option reentrant stack
    %x COMMENT
    %%
    "//"                 yy_push_state( COMMENT, yy_globals);
    .|\n
    <COMMENT>\n          yy_pop_state( yy_globals );
    <COMMENT>[^\n]+      fprintf( yyout_r, "%s\n", yytext_r);
    %%
    int main ( int argc, char * argv[] ) 
    {
        void * scanner;
        
        yylex_init ( &scanner );
        yylex ( scanner );
        yylex_destroy ( scanner );
    return 0;
   }
@end verbatim
@end example

@node reentrant detail, bison pure, reentrant example, reentrant
@section The Reentrant API in Detail

Here are the things you need to do or know to use the reentrant C API of
@code{flex}.

@menu
* specify reentrant::           
* extra reentrant argument::    
* global replacement::          
* init and destroy and destroy::  
* accessor methods::            
* extra data::                  
@end menu

@node specify reentrant, extra reentrant argument, reentrant detail, reentrant detail
@subsection Declaring a Scanner as Reentrant

 %option reentrant
must be specified.

Notice that @code{%option reentrant} is specified in the above example
(@pxref{reentrant example}. Had this option not been specified,
@code{flex} would have happily generated a non-reentrant scanner without
complaining. You may explicitly specify @code{%option noreentrant}, if
you do @emph{not} want a reentrant scanner, although it is not
necessary. The default is to generate a non-reentrant scanner.

@node extra reentrant argument, global replacement, specify reentrant, reentrant detail
@subsection The Extra Argument

All functions take one additional argument: @code{yy_globals}.

Notice that the calls to @code{yy_push_state} and @code{yy_pop_state}
both have an argument, @code{yy_globals} , that is not present in a
non-reentrant scanner.  Here are the declarations of
@code{yy_push_state} and @code{yy_pop_state} in the generated scanner:

@example
@verbatim
    static void yy_push_state  ( int new_state , void * yy_globals ) ;
    static void yy_pop_state  ( void * yy_globals  ) ;
@end verbatim
@end example

Notice that the argument @code{yy_globals} appears in the declaration of
both functions.  In fact, all @code{flex} functions in a reentrant
scanner have this additional argument.  It is always the last argument
in the argument list, it is always of type @code{void *}, and it is
always named @code{yy_globals}.  As you may have guessed,
@code{yy_globals} is a pointer to an opaque data structure encapsulating
the current state of the scanner.  For a list of function declarations,
see @ref{reentrant functions}. Note that preprocessor macros, such as
@code{BEGIN}, @code{ECHO}, and @code{REJECT}, do not take this
additional argument.

@node global replacement, init and destroy and destroy, extra reentrant argument, reentrant detail
@subsection Global Variables Replaced

All global variables are replaced by their @code{_r} equivalents.

Notice in the above example that @code{yyout} and @code{yytext} are
replaced by @code{yyout_r} and @code{yytext_r}.  These are macros that
will expand to their equivalent lvalue.  All of the familiar @code{flex}
globals have been replaced by their @code{_r} equivalents. Wherever you
would normally use @code{yytext} in actions, you must use @code{yytext_r}
instead. This rule applies to all @code{flex} variables. The following
is an example that uses the @code{_r} macros:

@example
@verbatim
    %%
        #define SWAP(a,b) do{int t=a; a=b; b=t;}while(0)
    "reverse me"  {
            int i;
            for( i =0; i  yyleng_r/2 ; i++ )
                SWAP( yytext_r[i], yytext_r[yyleng_r-i-1] );
            fprintf( yyout_r, "%s", yytext_r );
           }
@end verbatim
@end example

One important thing to remember about
@code{yytext_r}
and friends is that
@code{yytext_r}
is not a global variable in a reentrant
scanner, you can not access it directly from outside an action or from
other functions. You must use the accessor method 
@code{yyget_text}
to accomplish this. (See below).

@node init and destroy and destroy, accessor methods, global replacement, reentrant detail
@subsection init and destroy functions

@code{yylex_init} and @code{yylex_destroy} must be called before and
after @code{yylex}, respectively.

@example
@verbatim
    int yylex_init ( void ** ptr_yy_globals ) ;
    int yylex ( void * yy_globals ) ;
    int yylex_destroy ( void * yy_globals ) ;
@end verbatim
@end example

The function @code{yylex_init} must be called before calling any other
function. The argument to @code{yylex_init} is the address of an
uninitialized pointer to be filled in by @code{flex}. The contents of
@code{ptr_yy_globals} need not be initialized, since @code{flex} will
overwrite it anyway. The value stored in @code{ptr_yy_globals} should
thereafter be passed to @code{yylex()} and @b{yylex_destroy()}.  Flex
does not save the argument passed to @code{yylex_init}, so it is safe to
pass the address of a local pointer to @code{yylex_init}.  The function
@code{yylex} should be familiar to you by now. The reentrant version
takes one argument, which is the value returned (via an argument) by
@code{yylex_init}.  Otherwise, it behaves the same as the non-reentrant
version of @code{yylex}.  The function @code{yylex_destroy} should be
called to free resources used by the scanner. After @code{yylex_destroy}
is called, the contents of @code{yyglobals} should not be used.  Of
course, there is no need to destroy a scanner if you plan to reuse it.
A @code{flex} scanner (both reentrant and non-reentrant) may be
restarted by calling @code{yyrestart}.

@node accessor methods, extra data, init and destroy and destroy, reentrant detail
@subsection Accessing Variables with Reentrant Scanners

Accessor methods (get/set functions) provide access to common
@code{flex} variables.

Many scanners that you build will be part of a larger project. Portions
of your project will need access to @code{flex} values, such as
@code{yytext}.  In a non-reentrant scanner, these values are global, so
there is no problem. However, in a reentrant scanner, there are no
global @code{flex} values. You can not access them directly.  Instead,
you must access @code{flex} values using accessor methods (get/set
functions). Each accessor method is named @code{yyget_NAME} or
@code{yyset_NAME}, where @code{NAME} is the name of the @code{flex}
variable you want. For example:

@example
@verbatim
    /* Set the last character of yytext to NULL. */
    void chop ( void * scanner )
    {
        int len = yyget_leng( scanner );        
        yyget_text( scanner )[len - 1] = '\0';        
   }
@end verbatim
@end example

The above code may be called from within an action like this:

@example
@verbatim
    %%
    .+\n    { chop( yy_globals );}
@end verbatim
@end example

@node extra data,  , accessor methods, reentrant detail
@subsection Extra Data

User-specific data can be stored in @code{yyextra_r}.

In a reentrant scanner, it is unwise to use global variables to
communicate with or maintain state between different pieces of your program.
However, you may need access to external data or invoke external functions
from within the scanner actions.
Likewise, you may need to pass information to your scanner
(e.g., open file descriptors, or database connections).
In a non-reentrant scanner, the only way to do this would be through the
use of global variables.
@code{Flex} allows you to store arbitrary, ``extra'' data in a scanner.
This data is accessible through the accessor methods
@code{yyget_extra}
and
@code{yyset_extra}
from outside the scanner, and through the shortcut macro
@code{yyextra_r}
from within the scanner itself. They are defined as follows:

@example
@verbatim
    #define YY_EXTRA_TYPE  void*
    YY_EXTRA_TYPE  yyget_extra ( void * scanner ) ;
    void yyset_extra ( YY_EXTRA_TYPE arbitrary_data , void * scanner) ;
@end verbatim
@end example

By default, @code{YY_EXTRA_TYPE} is defined as type @code{void *}.  You
will have to cast @code{yyextra_r} and the return value from
@code{yyget_extra} to the appropriate value each time you access the
extra data.  To avoid casting, you may override the default type by
defining @code{YY_EXTRA_TYPE} in section 1 of your scanner:

@example
@verbatim
    /* An example of overriding YY_EXTRA_TYPE. */
    %{    
    #include <sys/stat.h>
    #include <unistd.h>
    #define YY_EXTRA_TYPE  struct stat*
    %}
    %option reentrant
    %%
          
    __filesize__     printf( "%ld", yyextra_r->st_size  );
    __lastmod__      printf( "%ld", yyextra_r->st_mtime );
    %%
    void scan_file( char* filename )
    {
        void * scanner;
        struct stat buf;
        
        yylex_init ( &scanner );
        yyset_in( fopen(filename,"r"), scanner );
        
        stat( filename, &buf);
        yyset_extra( &buf, scanner );
        yylex ( scanner );
        yylex_destroy( scanner );
   }
@end verbatim
@end example

@node bison pure, reentrant functions, reentrant detail, reentrant
@section REENTRANT C SCANNERS WITH BISON PURE PARSERS

This section describes the @code{flex} features useful when integrating
@code{flex} with @code{bison}.  Skip this section if you are not using
@code{bison} with your scanner.  Here we discuss only the @code{flex}
half of the @code{flex} and @code{bison} pair.  We do not discuss
@code{bison} in any detail.  For more information about generating pure
@code{bison} parsers, see @ref{Top, , , bison, The GNU Bison Manual} A
@code{bison}-compatible scanner is generated by declaring @samp{%option
reentrant-bison} or by supplying @samp{-Rb} when invoking @code{flex}
from the command line.  This instructs @code{flex} that the macros
@code{yylval_r} and @code{yylloc_r} may be used. The data types for
@code{yylval_r} and @code{yylloc_r}, (@code{YYSTYPE} and @code{YYLTYPE},
are typically defined in a header file, included in section 1 of the
@code{flex} input file.  @code{%option reentrant-bison} implies
@code{%option reentrant}.  If @code{%option reentrant-bison} is
specified, @code{flex} provides support for the functions
@code{yyget_lval}, @code{yyset_lval}, @code{yyget_lloc}, and
@code{yyset_lloc}, defined below, and the corresponding macros
@code{yylval_r} and @code{yylloc_r}, for use within actions.

@example
@verbatim
    YYSTYPE * yyget_lval ( void * scanner ) ;
    void yyset_lval ( YYSTYPE * lvalp, void * scanner );
    YYLTYPE * yyget_lloc ( void * scanner ) ;
    void yyset_lloc ( YYLTYPE * llocp, void * scanner );
@end verbatim
@end example

Accordingly, the declaration of yylex becomes one of the following:

@example
@verbatim
      int yylex ( YYSTYPE * lvalp, void * scanner );
      int yylex ( YYSTYPE * lvalp, YYLTYPE * llocp, void * scanner );
@end verbatim
@end example

Note that the macros @code{yylval_r} and @code{yylloc_r} evaluate to
pointers.  Support for @code{yylloc} is optional in @code{bison}, so it
is optional in @code{flex} as well. This support is automatically
handled by @code{flex}.  Specifically, support for @code{yyloc} is only
present in a @code{flex} scanner if the preprocessor symbol
@code{YYLTYPE} is defined.  The following is an example of a @code{flex}
scanner that is @code{bison}-compatible.

@example
@verbatim
    /* Scanner for "C" assignment statements... sort of. */
    %{
    #include "y.tab.h"  /* Generated by bison. */
    %}
  
    %option reentrant-bison
    %
   
    [[:digit:]]+  { yylval_r->num = atoi(yytext_r);   return NUMBER;}
    [[:alnum:]]+  { yylval_r->str = strdup(yytext_r); return STRING;}
    "="|";"       { return yytext_r[0];}
    .  {}
    %
@end vernbatim
@end example

As you can see, there really is no magic here. We just use
@code{yylval_r} as we would any other variable. The data type of
@code{yylval_r} is generated by @code{bison}, and included in the file
@file{y.tab.h}.  Here is the corresponding @code{bison} parser:

@example
@verbatim
    /* Parser to convert "C" assignments to lisp. */
    %{
    /* Pass the argument to yyparse through to yylex. */
    #define YYPARSE_PARAM scanner
    #define YYLEX_PARAM   scanner
    %}
    %pure_parser
    %union {
        int num;
        char* str;
   }
    %token <str> STRING
    %token <num> NUMBER 
    %%
    assignment:
        STRING '=' NUMBER ';' {
            printf( "(setf %s %d)", $1, $3 );
       }
    ;
@end verbatim
@end example

@node reentrant functions,  , bison pure, reentrant
@section FUNCTIONS AND MACROS AVAILABLE IN REENTRANT C SCANNERS

The ffollowing Functions are available in a reentrant scanner:

@example
@verbatim
    char *yyget_text ( void * scanner );
    int yyget_leng ( void * scanner );
    FILE *yyget_in ( void * scanner );
    FILE *yyget_out ( void * scanner );
    int yyget_lineno ( void * scanner );
    YY_EXTRA_TYPE yyget_extra ( void * scanner );
    void yyset_in  ( FILE * in_str , void * scanner );
    void yyset_out  ( FILE * out_str , void * scanner );
    void yyset_lineno ( int line_number , void * scanner );
    void yyset_extra ( YY_EXTRA_TYPE user_defined , void * scanner );
@end verbatim
@end example

There are no ``set'' functions for yytext_r and yyleng_r. This is intentional.

The following Macro shortcuts are available in actions in a reentrant
scanner:

@example
@verbatim
    yytext_r
    yyleng_r
    yyin_r
    yyout_r
    yylineno_r
    yyextra_r
@end verbatim
@end example

In a reentrant C scanner, support for yylineno_r is always present
(i.e., you may access yylineno_r), but the value is never modified by
@code{flex} unless @code{%option yylineno} is enabled. This is to allow
the user to maintain the line count independently of @code{flex}.

The following functions and macros are made available when @code{%option
reentrant-bison} (@samp{-Rb}) is specified:

@example
@verbatim
    YYSTYPE * yyget_lval ( void * scanner );
    YYLTYPE *yyget_lloc ( void * scanner );
    void yyset_lval ( YYSTYPE * yylvalp , void * scanner );
    void yyset_lloc ( YYLTYPE * yyllocp , void * scanner );
    yylval_r
    yylloc_r
@end verbatim
@end example

Support for yylloc is dependent upon the presence of the preprocessor
symbol @code{YYLTYPE}.  Support for yylval relies on the type
@code{YYSTYPE} to be defined. Typically, these definitions are generated
by @code{bison}, in a .h file, and are included in section 1 of the
@code{flex} input.

@node lex and posix, diagnostics, reentrant, Top
@chapter INCOMPATIBILITIES WITH LEX AND POSIX

@code{flex} is a rewrite of the AT&T Unix @emph{lex} tool (the two
implementations do not share any code, though), with some extensions and
incompatibilities, both of which are of concern to those who wish to
write scanners acceptable to both implementations.  @code{flex} is fully
compliant with the POSIX @code{lex} specification, except that when
using @code{%pointer} (the default), a call to @code{unput()} destroys
the contents of @code{yytext}, which is counter to the POSIX
specification.  In this section we discuss all of the known areas of
incompatibility between @code{flex}, AT&T @code{lex}, and the POSIX
specification.  @code{flex}'s @samp{-l} option turns on maximum
compatibility with the original AT&T @code{lex} implementation, at the
cost of a major loss in the generated scanner's performance.  We note
below which incompatibilities can be overcome using the @samp{-l}
option.  @code{flex} is fully compatible with @code{lex} with the
following exceptions:

@itemize
@item 
The undocumented @code{lex} scanner internal variable @code{yylineno} is
not supported unless @samp{-l} or @code{%option yylineno} is used.

@item
@code{yylineno} should be maintained on a per-buffer basis, rather than
a per-scanner (single global variable) basis.

@item
@code{yylineno} is not part of the POSIX specification.

@item 
The @code{input()} routine is not redefinable, though it may be called
to read characters following whatever has been matched by a rule.  If
@code{input()} encounters an end-of-file the normal @code{yywrap()}
processing is done.  A ``real'' end-of-file is returned by
@code{input()} as @code{EOF}.

@item
Input is instead controlled by defining the @code{YY_INPUT()} macro.

@item
The @code{flex} restriction that @code{input()} cannot be redefined is
in accordance with the POSIX specification, which simply does not
specify any way of controlling the scanner's input other than by making
an initial assignment to @file{yyin}.

@item 
The @code{unput()} routine is not redefinable.  This restriction is in
accordance with POSIX.

@item 
@code{flex} scanners are not as reentrant as @code{lex} scanners.  In
particular, if you have an interactive scanner and an interrupt handler
which long-jumps out of the scanner, and the scanner is subsequently
called again, you may get the following message:

@example
@verbatim
    fatal @code{flex} scanner internal error--end of buffer missed
@end verbatim
@end example

To reenter the scanner, first use:

@example
@verbatim
    yyrestart( yyin );
@end verbatim
@end example

Note that this call will throw away any buffered input; usually this
isn't a problem with an interactive scanner. @xref{reentrant}, for
@code{flex}'s reentrant API.

@item
Also note that @code{flex} C++ scanner classes
@emph{are}
reentrant, so if using C++ is an option for you, you should use
them instead.  @xref{cxx}, and @ref{reentrant}  for details.

@item 
@code{output()} is not supported.  Output from the @b{ECHO} macro is
done to the file-pointer @code{yyout} (default @file{stdout)}.

@item
@code{output()} is not part of the POSIX specification.

@item 
@code{lex} does not support exclusive start conditions (%x), though they
are in the POSIX specification.

@item 
When definitions are expanded, @code{flex} encloses them in parentheses.
With @code{lex}, the following:

@example
@verbatim
    NAME    [A-Z][A-Z0-9]*
    %%
    foo{NAME}?      printf( "Found it\n" );
    %%
@end verbatim
@end example

will not match the string @samp{foo} because when the macro is expanded
the rule is equivalent to @samp{foo[A-Z][A-Z0-9]*?}  and the precedence
is such that the @samp{?} is associated with @samp{[A-Z0-9]*}.  With
@code{flex}, the rule will be expanded to @samp{foo([A-Z][A-Z0-9]*)?}
and so the string @samp{foo} will match.

@item
Note that if the definition begins with @samp{^} or ends with @samp{$}
then it is @emph{not} expanded with parentheses, to allow these
operators to appear in definitions without losing their special
meanings.  But the @samp{<s>}, @samp{/}, and @code{<<EOF>>} operators
cannot be used in a @code{flex} definition.

@item
Using @samp{-l} results in the @code{lex} behavior of no parentheses
around the definition.

@item
The POSIX specification is that the definition be enclosed in parentheses.

@item 
Some implementations of @code{lex} allow a rule's action to begin on a
separate line, if the rule's pattern has trailing whitespace:

@example
@verbatim
    %%
    foo|bar<space here>
      { foobar_action();}
@end verbatim
@end example

@code{flex} does not support this feature.

@item 
The @code{lex} @code{%r} (generate a Ratfor scanner) option is not
supported.  It is not part of the POSIX specification.

@item 
After a call to @code{unput()}, @emph{yytext} is undefined until the
next token is matched, unless the scanner was built using @code{%array}.
This is not the case with @code{lex} or the POSIX specification.  The
@samp{-l} option does away with this incompatibility.

@item 
The precedence of the @samp{@{,@}} (numeric range) operator is
different.  @code{lex} interprets @samp{abc@{1,3@}} as match one, two,
or three occurrences of @samp{abc}'', whereas @code{flex} interprets it
as ``match @samp{ab} followed by one, two, or three occurrences of
@samp{c}''.  The latter is in agreement with the POSIX specification.

@item 
The precedence of the @samp{^} operator is different.  @code{lex}
interprets @samp{^foo|bar} as ``match either 'foo' at the beginning of a
line, or 'bar' anywhere'', whereas @code{flex} interprets it as ``match
either @samp{foo} or @samp{bar} if they come at the beginning of a
line''.  The latter is in agreement with the POSIX specification.

@item 
The special table-size declarations such as @code{%a} supported by
@code{lex} are not required by @code{flex} scanners..  @code{flex}
ignores them.
@item 
The name @code{FLEX_SCANNER} is @code{#define}'d so scanners may be
written for use with either @code{flex} or @code{lex}.  Scanners also
include @code{YY_FLEX_MAJOR_VERSION} and @code{YY_FLEX_MINOR_VERSION}
indicating which version of @code{flex} generated the scanner (for
example, for the 2.5 release, these defines would be 2 and 5
respectively).
@end itemize

The following @code{flex} features are not included in @code{lex} or the
POSIX specification:

@example
@verbatim
    C++ scanners
    %option
    start condition scopes
    start condition stacks
    interactive/non-interactive scanners
    yy_scan_string() and friends
    yyterminate()
    yy_set_interactive()
    yy_set_bol()
    YY_AT_BOL()
   <<EOF>>
    <*>
    YY_DECL
    YY_START
    YY_USER_ACTION
    YY_USER_INIT
    #line directives
    %{}'s around actions
    reentrant C API
    multiple actions on a line
@end verbatim
@end example

plus almost all of the @code{flex} flags.  The last feature in the list
refers to the fact that with @code{flex} you can put multiple actions on
the same line, separated with semi-colons, while with @code{lex}, the
following:

@example
@verbatim
    foo    handle_foo(); ++num_foos_seen;
@end verbatim
@end example

is (rather surprisingly) truncated to

@example
@verbatim
    foo    handle_foo();
@end verbatim
@end example

@code{flex} does not truncate the action.  Actions that are not enclosed
in braces are simply terminated at the end of the line.

@node diagnostics, limitations, lex and posix, Top
@chapter DIAGNOSTICS

The following is a list of @code{flex} diagnostic messages:

@itemize
@item
@samp{warning, rule cannot be matched} indicates that the given rule
cannot be matched because it follows other rules that will always match
the same text as it.  For example, in the following @samp{foo} cannot be
matched because it comes after an identifier ``catch-all'' rule:

@example
@verbatim
    [a-z]+    got_identifier();
    foo       got_foo();
@end verbatim
@end example

Using @code{REJECT} in a scanner suppresses this warning.

@item
@samp{warning, -s option given but default rule can be matched} means
that it is possible (perhaps only in a particular start condition) that
the default rule (match any single character) is the only one that will
match a particular input.  Since @samp{-s} was given, presumably this is
not intended.  

@item
@code{reject_used_but_not_detected undefined} or
@code{yymore_used_but_not_detected undefined}. These errors can occur
at compile time.  They indicate that the scanner uses @code{REJECT} or
@code{yymore()} but that @code{flex} failed to notice the fact, meaning
that @code{flex} scanned the first two sections looking for occurrences
of these actions and failed to find any, but somehow you snuck some in
(via a #include file, for example).  Use @code{%option reject} or
@code{%option yymore} to indicate to @code{flex} that you really do use
these features.

@item
@samp{flex scanner jammed}. a scanner compiled with
@samp{-s} has encountered an input string which wasn't matched by any of
its rules.  This error can also occur due to internal problems.

@item
@samp{token too large, exceeds YYLMAX}. your scanner uses @code{%array}
and one of its rules matched a string longer than the @code{YYLMAX}
constant (8K bytes by default).  You can increase the value by
#define'ing @code{YYLMAX} in the definitions section of your @code{flex}
input.

@item
@samp{scanner requires -8 flag to use the character 'x'}. Your scanner
specification includes recognizing the 8-bit character @samp{'x'} and
you did not specify the -8 flag, and your scanner defaulted to 7-bit
because you used the @samp{-Cf} or @samp{-CF} table compression options.
See the discussion of the @samp{-7} flag, @ref{invoking flex}, for
details.

@item
@samp{flex scanner push-back overflow}. you used @code{unput()} to push
back so much text that the scanner's buffer could not hold both the
pushed-back text and the current token in @code{yytext}.  Ideally the
scanner should dynamically resize the buffer in this case, but at
present it does not.

@item
@samp{input buffer overflow, can't enlarge buffer because scanner uses
REJECT}.  the scanner was working on matching an extremely large token
and needed to expand the input buffer.  This doesn't work with scanners
that use @code{REJECT}.

@item
@samp{fatal flex scanner internal error--end of buffer missed}. This can
occur in a scanner which is reentered after a long-jump has jumped out
(or over) the scanner's activation frame.  Before reentering the
scanner, use:
@example
@verbatim
    yyrestart( yyin );
@end verbatim
@end example
or, as noted above, switch to using the C++ scanner class.

@item
@samp{too many start conditions in <> construct!}  you listed more start
conditions in a <> construct than exist (so you must have listed at
least one of them twice).
@end itemize

@node limitations, bibliography, diagnostics, Top
@chapter Limitations

Some trailing context patterns cannot be properly matched and generate
warning messages (@samp{dangerous trailing context}).  These are
patterns where the ending of the first part of the rule matches the
beginning of the second part, such as @samp{zx*/xy*}, where the 'x*'
matches the 'x' at the beginning of the trailing context.  (Note that
the POSIX draft states that the text matched by such patterns is
undefined.)  For some trailing context rules, parts which are actually
fixed-length are not recognized as such, leading to the abovementioned
performance loss.  In particular, parts using @samp{|} or @samp{@{n@}}
(such as @samp{foo@{3@}}) are always considered variable-length.
Combining trailing context with the special @samp{|} action can result
in @emph{fixed} trailing context being turned into the more expensive
@emph{variable} trailing context.  For example, in the following:

@example
@verbatim
    %%
    abc      |
    xyz/def
@end verbatim
@end example

Use of @code{unput()} invalidates yytext and yyleng, unless the
@code{%array} directive or the @samp{-l} option has been used.
Pattern-matching of @code{NUL}s is substantially slower than matching
other characters.  Dynamic resizing of the input buffer is slow, as it
entails rescanning all the text matched so far by the current (generally
huge) token.  Due to both buffering of input and read-ahead, you cannot
intermix calls to @file{<stdio.h>} routines, such as, @b{getchar()},
with @code{flex} rules and expect it to work.  Call @code{input()}
instead.  The total table entries listed by the @samp{-v} flag excludes
the number of table entries needed to determine what rule has been
matched.  The number of entries is equal to the number of DFA states if
the scanner does not use @code{REJECT}, and somewhat greater than the
number of states if it does.  @code{REJECT} cannot be used with the
@samp{-f} or @samp{-F} options.

The @code{flex} internal algorithms need documentation.

@node bibliography, copyright, limitations, Top
@chapter Additional Reading

You may wish to read more about the following programs:
@itemize
@item lex
@item yacc
@item sed
@item awk
@end itemize

The following books may contain material of interest:

John Levine, Tony Mason, and Doug Brown,
@emph{Lex & Yacc},
O'Reilly and Associates.  Be sure to get the 2nd edition.

M. E. Lesk and E. Schmidt,
@emph{LEX -- Lexical Analyzer Generator}

Alfred Aho, Ravi Sethi and Jeffrey Ullman, @emph{Compilers: Principles,
Techniques and Tools}, Addison-Wesley (1986).  Describes the
pattern-matching techniques used by @code{flex} (deterministic finite
automata).

@node copyright, reporting bugs, bibliography, Top
@chapter Copyright

The flex manual is placed under the same licensing conditions as the
rest of flex:

Copyright @copyright{} 1990, 1997 The Regents of the University of California.
All rights reserved.

This code is derived from software contributed to Berkeley by
Vern Paxson.

The United States Government has rights in this work pursuant
to contract no. DE-AC03-76SF00098 between the United States
Department of Energy and the University of California.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

@enumerate
@item
Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.

@item
Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
@end enumerate

Neither the name of the University nor the names of its contributors
may be used to endorse or promote products derived from this software
without specific prior written permission.

THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.

@node reporting bugs,  , copyright, Top
@chapter Reporting Bugs

If you have problems with @code{flex} or think you have found a bug,
please send mail detailing your problem to
@email{help-flex@@gnu.org}. Patches are always welcome.

@bye
